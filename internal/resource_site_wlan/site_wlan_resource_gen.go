// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_site_wlan

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func SiteWlanResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"acct_immediate_update": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "enable coa-immediate-update and address-change-immediate-update on the access profile.",
				MarkdownDescription: "enable coa-immediate-update and address-change-immediate-update on the access profile.",
				Default:             booldefault.StaticBool(false),
			},
			"acct_interim_interval": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
				MarkdownDescription: "how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
				Validators: []validator.Int64{
					int64validator.Between(0, 65535),
				},
				Default: int64default.StaticInt64(0),
			},
			"acct_servers": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"host": schema.StringAttribute{
							Required:            true,
							Description:         "ip / hostname of RADIUS server",
							MarkdownDescription: "ip / hostname of RADIUS server",
						},
						"keywrap_enabled": schema.BoolAttribute{
							Optional: true,
						},
						"keywrap_format": schema.StringAttribute{
							Optional: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"hex",
									"ascii",
								),
							},
						},
						"keywrap_kek": schema.StringAttribute{
							Optional: true,
						},
						"keywrap_mack": schema.StringAttribute{
							Optional: true,
						},
						"port": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "Acct port of RADIUS server",
							MarkdownDescription: "Acct port of RADIUS server",
							Default:             int64default.StaticInt64(1813),
						},
						"secret": schema.StringAttribute{
							Required:            true,
							Sensitive:           true,
							Description:         "secret of RADIUS server",
							MarkdownDescription: "secret of RADIUS server",
						},
					},
					CustomType: AcctServersType{
						ObjectType: types.ObjectType{
							AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "list of RADIUS accounting servers, optional, order matters where the first one is treated as primary",
				MarkdownDescription: "list of RADIUS accounting servers, optional, order matters where the first one is treated as primary",
			},
			"airwatch": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"api_key": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "API Key",
						MarkdownDescription: "API Key",
						Default:             stringdefault.StaticString(""),
					},
					"console_url": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "console URL",
						MarkdownDescription: "console URL",
						Default:             stringdefault.StaticString(""),
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"password": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Sensitive:           true,
						Description:         "password",
						MarkdownDescription: "password",
						Default:             stringdefault.StaticString(""),
					},
					"username": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "username",
						MarkdownDescription: "username",
						Default:             stringdefault.StaticString(""),
					},
				},
				CustomType: AirwatchType{
					ObjectType: types.ObjectType{
						AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "airwatch wlan settings",
				MarkdownDescription: "airwatch wlan settings",
			},
			"allow_ipv6_ndp": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through",
				MarkdownDescription: "only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through",
				Default:             booldefault.StaticBool(true),
			},
			"allow_mdns": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through",
				MarkdownDescription: "only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through",
				Default:             booldefault.StaticBool(false),
			},
			"allow_ssdp": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "only applicable when `limit_bcast`==`tru`e, which allows SSDP",
				MarkdownDescription: "only applicable when `limit_bcast`==`tru`e, which allows SSDP",
				Default:             booldefault.StaticBool(false),
			},
			"ap_ids": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "list of device ids",
				MarkdownDescription: "list of device ids",
				Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
			},
			"app_limit": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"apps": schema.MapAttribute{
						ElementType:         types.Int64Type,
						Optional:            true,
						Description:         "Map from app key to bandwidth in kbps. \nProperty key is the app key, defined in Get Application List",
						MarkdownDescription: "Map from app key to bandwidth in kbps. \nProperty key is the app key, defined in Get Application List",
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"wxtag_ids": schema.MapAttribute{
						ElementType:         types.Int64Type,
						Optional:            true,
						Computed:            true,
						Description:         "Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps\nProperty key is the wxtag id",
						MarkdownDescription: "Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps\nProperty key is the wxtag id",
					},
				},
				CustomType: AppLimitType{
					ObjectType: types.ObjectType{
						AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "bandwidth limiting for apps (applies to up/down)",
				MarkdownDescription: "bandwidth limiting for apps (applies to up/down)",
			},
			"app_qos": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"apps": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"dscp": schema.Int64Attribute{
									Optional: true,
								},
								"dst_subnet": schema.StringAttribute{
									Optional:            true,
									Description:         "subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)",
									MarkdownDescription: "subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)",
								},
								"src_subnet": schema.StringAttribute{
									Optional:            true,
									Description:         "subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)",
									MarkdownDescription: "subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)",
								},
							},
							CustomType: AppsType{
								ObjectType: types.ObjectType{
									AttrTypes: AppsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"others": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"dscp": schema.Int64Attribute{
									Optional: true,
								},
								"dst_subnet": schema.StringAttribute{
									Optional: true,
								},
								"port_ranges": schema.StringAttribute{
									Optional: true,
								},
								"protocol": schema.StringAttribute{
									Optional: true,
								},
								"src_subnet": schema.StringAttribute{
									Optional: true,
								},
							},
							CustomType: OthersType{
								ObjectType: types.ObjectType{
									AttrTypes: OthersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
							listvalidator.UniqueValues(),
						},
					},
				},
				CustomType: AppQosType{
					ObjectType: types.ObjectType{
						AttrTypes: AppQosValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "app qos wlan settings",
				MarkdownDescription: "app qos wlan settings",
			},
			"apply_to": schema.StringAttribute{
				Optional: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"site",
						"wxtags",
						"aps",
					),
				},
			},
			"arp_filter": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to enable smart arp filter",
				MarkdownDescription: "whether to enable smart arp filter",
				Default:             booldefault.StaticBool(false),
			},
			"auth": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"anticlog_threshold": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "SAE anti-clogging token threshold",
						MarkdownDescription: "SAE anti-clogging token threshold",
						Validators: []validator.Int64{
							int64validator.Between(16, 32),
						},
						Default: int64default.StaticInt64(16),
					},
					"eap_reauth": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to trigger EAP reauth when the session ends",
						MarkdownDescription: "whether to trigger EAP reauth when the session ends",
						Default:             booldefault.StaticBool(false),
					},
					"enable_mac_auth": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to enable MAC Auth, uses the same auth_servers",
						MarkdownDescription: "whether to enable MAC Auth, uses the same auth_servers",
						Default:             booldefault.StaticBool(false),
					},
					"key_idx": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "when type=wep",
						MarkdownDescription: "when type=wep",
						Validators: []validator.Int64{
							int64validator.Between(1, 4),
						},
						Default: int64default.StaticInt64(1),
					},
					"keys": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "when type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length",
						MarkdownDescription: "when type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length",
					},
					"multi_psk_only": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to only use multi_psk",
						MarkdownDescription: "whether to only use multi_psk",
						Default:             booldefault.StaticBool(false),
					},
					"owe": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "`enabled` means transition mode",
						MarkdownDescription: "`enabled` means transition mode",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"enabled",
								"disabled",
								"required",
							),
						},
						Default: stringdefault.StaticString("disabled"),
					},
					"pairwise": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "when type=psk / eap, one or more of wpa2-ccmp / wpa1-tkip / wpa1-ccmp / wpa2-tkip",
						MarkdownDescription: "when type=psk / eap, one or more of wpa2-ccmp / wpa1-tkip / wpa1-ccmp / wpa2-tkip",
					},
					"private_wlan": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether private wlan is enabled. only applicable to multi_psk mode",
						MarkdownDescription: "whether private wlan is enabled. only applicable to multi_psk mode",
						Default:             booldefault.StaticBool(false),
					},
					"psk": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Sensitive:           true,
						Description:         "when type=psk, 8-64 characters, or 64 hex characters",
						MarkdownDescription: "when type=psk, 8-64 characters, or 64 hex characters",
						Validators: []validator.String{
							stringvalidator.LengthBetween(8, 64),
						},
						Default: stringdefault.StaticString(""),
					},
					"type": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"open",
								"psk",
								"wep",
								"eap",
								"eap192",
								"psk-tkip",
								"psk-wpa2-tkip",
							),
						},
						Default: stringdefault.StaticString("open"),
					},
					"wep_as_secondary_auth": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "enable WEP as secondary auth",
						MarkdownDescription: "enable WEP as secondary auth",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: AuthType{
					ObjectType: types.ObjectType{
						AttrTypes: AuthValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "authentication wlan settings",
				MarkdownDescription: "authentication wlan settings",
			},
			"auth_server_selection": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "When ordered, AP will prefer and go back to the first server if possible",
				MarkdownDescription: "When ordered, AP will prefer and go back to the first server if possible",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"ordered",
						"unordered",
					),
				},
				Default: stringdefault.StaticString("ordered"),
			},
			"auth_servers": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"host": schema.StringAttribute{
							Required:            true,
							Description:         "ip / hostname of RADIUS server",
							MarkdownDescription: "ip / hostname of RADIUS server",
						},
						"keywrap_enabled": schema.BoolAttribute{
							Optional: true,
						},
						"keywrap_format": schema.StringAttribute{
							Optional: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"hex",
									"ascii",
								),
							},
						},
						"keywrap_kek": schema.StringAttribute{
							Optional: true,
						},
						"keywrap_mack": schema.StringAttribute{
							Optional: true,
						},
						"port": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "Auth port of RADIUS server",
							MarkdownDescription: "Auth port of RADIUS server",
							Default:             int64default.StaticInt64(1812),
						},
						"secret": schema.StringAttribute{
							Required:            true,
							Sensitive:           true,
							Description:         "secret of RADIUS server",
							MarkdownDescription: "secret of RADIUS server",
						},
					},
					CustomType: AuthServersType{
						ObjectType: types.ObjectType{
							AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one is treated as primary",
				MarkdownDescription: "list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one is treated as primary",
			},
			"auth_servers_nas_id": schema.StringAttribute{
				Optional:            true,
				Description:         "optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers",
				MarkdownDescription: "optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers",
			},
			"auth_servers_nas_ip": schema.StringAttribute{
				Optional:            true,
				Description:         "optional, NAS-IP-ADDRESS to use",
				MarkdownDescription: "optional, NAS-IP-ADDRESS to use",
			},
			"auth_servers_retries": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default value to 3.",
				MarkdownDescription: "radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default value to 3.",
				Default:             int64default.StaticInt64(2),
			},
			"auth_servers_timeout": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when setting auth_servers_timeout and is set to default value of 10.",
				MarkdownDescription: "radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when setting auth_servers_timeout and is set to default value of 10.",
				Default:             int64default.StaticInt64(5),
			},
			"band_steer": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to enable band_steering, this works only when band==both",
				MarkdownDescription: "whether to enable band_steering, this works only when band==both",
				Default:             booldefault.StaticBool(false),
			},
			"band_steer_force_band5": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "force dual_band capable client to connect to 5G",
				MarkdownDescription: "force dual_band capable client to connect to 5G",
				Default:             booldefault.StaticBool(false),
			},
			"bands": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "list of radios that the wlan should apply to",
				MarkdownDescription: "list of radios that the wlan should apply to",
			},
			"block_blacklist_clients": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to block the clients in the blacklist (up to first 256 macs)",
				MarkdownDescription: "whether to block the clients in the blacklist (up to first 256 macs)",
				Default:             booldefault.StaticBool(false),
			},
			"bonjour": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"additional_vlan_ids": schema.ListAttribute{
						ElementType:         types.Int64Type,
						Required:            true,
						Description:         "additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses",
						MarkdownDescription: "additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses",
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false",
						MarkdownDescription: "whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false",
						Default:             booldefault.StaticBool(false),
					},
					"services": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"disable_local": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "whether to prevent wireless clients to discover bonjour devices on the same WLAN",
									MarkdownDescription: "whether to prevent wireless clients to discover bonjour devices on the same WLAN",
									Default:             booldefault.StaticBool(false),
								},
								"radius_groups": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "optional, if the service is further restricted for certain RADIUS groups",
									MarkdownDescription: "optional, if the service is further restricted for certain RADIUS groups",
								},
								"scope": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "how bonjour services should be discovered for the same WLAN",
									MarkdownDescription: "how bonjour services should be discovered for the same WLAN",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"same_site",
											"same_map",
											"same_ap",
										),
									},
									Default: stringdefault.StaticString("same_site"),
								},
							},
							CustomType: ServicesType{
								ObjectType: types.ObjectType{
									AttrTypes: ServicesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Required:            true,
						Description:         "what services are allowed. \nProperty key is the service name",
						MarkdownDescription: "what services are allowed. \nProperty key is the service name",
					},
				},
				CustomType: BonjourType{
					ObjectType: types.ObjectType{
						AttrTypes: BonjourValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "bonjour gateway wlan settings",
				MarkdownDescription: "bonjour gateway wlan settings",
			},
			"cisco_cwa": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"allowed_hostnames": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "list of hostnames without http(s):// (matched by substring)",
						MarkdownDescription: "list of hostnames without http(s):// (matched by substring)",
					},
					"allowed_subnets": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "list of CIDRs",
						MarkdownDescription: "list of CIDRs",
					},
					"blocked_subnets": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "list of blocked CIDRs",
						MarkdownDescription: "list of blocked CIDRs",
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
				},
				CustomType: CiscoCwaType{
					ObjectType: types.ObjectType{
						AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA: https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html",
				MarkdownDescription: "Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA: https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html",
			},
			"client_limit_down": schema.Int64Attribute{
				Optional:            true,
				Description:         "kbps",
				MarkdownDescription: "kbps",
			},
			"client_limit_down_enabled": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "if downlink limiting per-client is enabled",
				MarkdownDescription: "if downlink limiting per-client is enabled",
				Default:             booldefault.StaticBool(false),
			},
			"client_limit_up": schema.Int64Attribute{
				Optional:            true,
				Description:         "kbps",
				MarkdownDescription: "kbps",
			},
			"client_limit_up_enabled": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "if uplink limiting per-client is enabled",
				MarkdownDescription: "if uplink limiting per-client is enabled",
				Default:             booldefault.StaticBool(false),
			},
			"coa_servers": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"disable_event_timestamp_check": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "whether to disable Event-Timestamp Check",
							MarkdownDescription: "whether to disable Event-Timestamp Check",
							Default:             booldefault.StaticBool(false),
						},
						"enabled": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"ip": schema.StringAttribute{
							Required: true,
						},
						"port": schema.Int64Attribute{
							Optional: true,
							Computed: true,
							Default:  int64default.StaticInt64(3799),
						},
						"secret": schema.StringAttribute{
							Required:  true,
							Sensitive: true,
						},
					},
					CustomType: CoaServersType{
						ObjectType: types.ObjectType{
							AttrTypes: CoaServersValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "list of COA (change of authorization) servers, optional",
				MarkdownDescription: "list of COA (change of authorization) servers, optional",
			},
			"disable_11ax": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "some old WLAN drivers may not be compatible",
				MarkdownDescription: "some old WLAN drivers may not be compatible",
				Default:             booldefault.StaticBool(false),
			},
			"disable_ht_vht_rates": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "to disable ht or vht rates",
				MarkdownDescription: "to disable ht or vht rates",
				Default:             booldefault.StaticBool(false),
			},
			"disable_uapsd": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to disable U-APSD",
				MarkdownDescription: "whether to disable U-APSD",
				Default:             booldefault.StaticBool(false),
			},
			"disable_v1_roam_notify": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "disable sending v2 roam notification messages",
				MarkdownDescription: "disable sending v2 roam notification messages",
				Default:             booldefault.StaticBool(false),
			},
			"disable_v2_roam_notify": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "disable sending v2 roam notification messages",
				MarkdownDescription: "disable sending v2 roam notification messages",
				Default:             booldefault.StaticBool(false),
			},
			"disable_wmm": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to disable WMM",
				MarkdownDescription: "whether to disable WMM",
				Default:             booldefault.StaticBool(false),
			},
			"dns_server_rewrite": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"radius_groups": schema.MapAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "map between radius_group and the desired DNS server (IPv4 only)\nProperty key is the RADIUS group, property value is the desired DNS Server",
						MarkdownDescription: "map between radius_group and the desired DNS server (IPv4 only)\nProperty key is the RADIUS group, property value is the desired DNS Server",
					},
				},
				CustomType: DnsServerRewriteType{
					ObjectType: types.ObjectType{
						AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)",
				MarkdownDescription: "for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)",
			},
			"dtim": schema.Int64Attribute{
				Optional: true,
				Computed: true,
				Default:  int64default.StaticInt64(2),
			},
			"dynamic_psk": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"default_psk": schema.StringAttribute{
						Optional:            true,
						Sensitive:           true,
						Description:         "default PSK to use if cloud WLC is not available, 8-63 characters",
						MarkdownDescription: "default PSK to use if cloud WLC is not available, 8-63 characters",
						Validators: []validator.String{
							stringvalidator.LengthBetween(8, 63),
						},
					},
					"default_vlan_id": schema.Int64Attribute{
						Optional: true,
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"force_lookup": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when 11r is enabled, we'll try to use the cached PMK, this can be disabled\n`false` means auto",
						MarkdownDescription: "when 11r is enabled, we'll try to use the cached PMK, this can be disabled\n`false` means auto",
						Default:             booldefault.StaticBool(false),
					},
					"source": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"radius",
								"cloud_psks",
							),
						},
						Default: stringdefault.StaticString("radius"),
					},
					"vlan_ids": schema.ListAttribute{
						ElementType: types.Int64Type,
						Optional:    true,
					},
				},
				CustomType: DynamicPskType{
					ObjectType: types.ObjectType{
						AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "for dynamic PSK where we get per_user PSK from Radius\ndynamic_psk allows PSK to be selected at runtime depending on context (wlan/site/user/...) thus following configurations are assumed (currently)\n- PSK will come from RADIUS server\n- AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed)\n- AP sends BSSID:SSID as Caller-Station-ID\n- `auth_servers` is required\n- PSK will come from cloud WLC if source is cloud_psks\n- default_psk will be used if cloud WLC is not available\n- `multi_psk_only` and `psk` is ignored\n- `pairwise` can only be wpa2-ccmp (for now, wpa3 support on the roadmap)",
				MarkdownDescription: "for dynamic PSK where we get per_user PSK from Radius\ndynamic_psk allows PSK to be selected at runtime depending on context (wlan/site/user/...) thus following configurations are assumed (currently)\n- PSK will come from RADIUS server\n- AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed)\n- AP sends BSSID:SSID as Caller-Station-ID\n- `auth_servers` is required\n- PSK will come from cloud WLC if source is cloud_psks\n- default_psk will be used if cloud WLC is not available\n- `multi_psk_only` and `psk` is ignored\n- `pairwise` can only be wpa2-ccmp (for now, wpa3 support on the roadmap)",
			},
			"dynamic_vlan": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"default_vlan_id": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "vlan_id to use when there’s no match from RADIUS",
						MarkdownDescription: "vlan_id to use when there’s no match from RADIUS",
						Validators: []validator.Int64{
							int64validator.Between(1, 4094),
						},
						Default: int64default.StaticInt64(999),
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to enable dynamic vlan",
						MarkdownDescription: "whether to enable dynamic vlan",
						Default:             booldefault.StaticBool(false),
					},
					"local_vlan_ids": schema.ListAttribute{
						ElementType:         types.Int64Type,
						Optional:            true,
						Description:         "vlan_ids to be locally bridged",
						MarkdownDescription: "vlan_ids to be locally bridged",
					},
					"type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco)",
						MarkdownDescription: "standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco)",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"standard",
								"airespace-interface-name",
							),
						},
						Default: stringdefault.StaticString("standard"),
					},
					"vlans": schema.MapAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "map between vlan_id (as string) to airespace interface names (comma-separated) or null for stndard mapping\n  * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \"\"\n  * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name",
						MarkdownDescription: "map between vlan_id (as string) to airespace interface names (comma-separated) or null for stndard mapping\n  * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \"\"\n  * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name",
					},
				},
				CustomType: DynamicVlanType{
					ObjectType: types.ObjectType{
						AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "for 802.1x",
				MarkdownDescription: "for 802.1x",
			},
			"enable_local_keycaching": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "enable AP-AP keycaching via multicast",
				MarkdownDescription: "enable AP-AP keycaching via multicast",
				Default:             booldefault.StaticBool(false),
			},
			"enable_wireless_bridging": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled",
				MarkdownDescription: "by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled",
				Default:             booldefault.StaticBool(false),
			},
			"enable_wireless_bridging_dhcp_tracking": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response packets to be forwarded to wireless",
				MarkdownDescription: "if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response packets to be forwarded to wireless",
				Default:             booldefault.StaticBool(false),
			},
			"enabled": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "if this wlan is enabled",
				MarkdownDescription: "if this wlan is enabled",
				Default:             booldefault.StaticBool(true),
			},
			"fast_dot1x_timers": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and ‘auth_server_retries’.",
				MarkdownDescription: "if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and ‘auth_server_retries’.",
				Default:             booldefault.StaticBool(false),
			},
			"hide_ssid": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to hide SSID in beacon",
				MarkdownDescription: "whether to hide SSID in beacon",
				Default:             booldefault.StaticBool(false),
			},
			"hostname_ie": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "include hostname inside IE in AP beacons / probe responses",
				MarkdownDescription: "include hostname inside IE in AP beacons / probe responses",
				Default:             booldefault.StaticBool(false),
			},
			"hotspot20": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"domain_name": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Description:         "whether to enable hotspot 2.0 config",
						MarkdownDescription: "whether to enable hotspot 2.0 config",
					},
					"nai_realms": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Validators: []validator.List{
							listvalidator.UniqueValues(),
						},
					},
					"operators": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "list of operators to support",
						MarkdownDescription: "list of operators to support",
					},
					"rcoi": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"venue_name": schema.StringAttribute{
						Optional:            true,
						Description:         "venue name, default is site name",
						MarkdownDescription: "venue name, default is site name",
					},
				},
				CustomType: Hotspot20Type{
					ObjectType: types.ObjectType{
						AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "hostspot 2.0 wlan settings",
				MarkdownDescription: "hostspot 2.0 wlan settings",
			},
			"id": schema.StringAttribute{
				Computed: true,
			},
			"inject_dhcp_option_82": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"circuit_id": schema.StringAttribute{
						Optional: true,
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to inject option 82 when forwarding DHCP packets",
						MarkdownDescription: "whether to inject option 82 when forwarding DHCP packets",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: InjectDhcpOption82Type{
					ObjectType: types.ObjectType{
						AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"interface": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "where this WLAN will be connected to",
				MarkdownDescription: "where this WLAN will be connected to",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"all",
						"eth0",
						"eth1",
						"eth2",
						"eth3",
						"wxtunnel",
						"mxtunnel",
						"site_mxedge",
					),
				},
				Default: stringdefault.StaticString("all"),
			},
			"isolation": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to stop clients to talk to each other",
				MarkdownDescription: "whether to stop clients to talk to each other",
				Default:             booldefault.StaticBool(false),
			},
			"l2_isolation": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "if isolation is enabled, whether to deny clients to talk to L2 on the LAN",
				MarkdownDescription: "if isolation is enabled, whether to deny clients to talk to L2 on the LAN",
				Default:             booldefault.StaticBool(false),
			},
			"legacy_overds": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning! Enabling this will cause problem for iOS devices.",
				MarkdownDescription: "legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning! Enabling this will cause problem for iOS devices.",
				Default:             booldefault.StaticBool(false),
			},
			"limit_bcast": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)",
				MarkdownDescription: "whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)",
				Default:             booldefault.StaticBool(false),
			},
			"limit_probe_response": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "limit probe response base on some heuristic rules",
				MarkdownDescription: "limit probe response base on some heuristic rules",
				Default:             booldefault.StaticBool(false),
			},
			"max_idletime": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "max idle time in seconds",
				MarkdownDescription: "max idle time in seconds",
				Validators: []validator.Int64{
					int64validator.Between(60, 86400),
				},
				Default: int64default.StaticInt64(1800),
			},
			"mist_nac": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when enabled:\n* `auth_servers` is ignored\n* `acct_servers` is ignored\n* `auth_servers_*` are ignored\n* `coa_servers` is ignored\n* `radsec` is ignored\n* `coa_enabled` is assumed",
						MarkdownDescription: "when enabled:\n* `auth_servers` is ignored\n* `acct_servers` is ignored\n* `auth_servers_*` are ignored\n* `coa_servers` is ignored\n* `radsec` is ignored\n* `coa_enabled` is assumed",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: MistNacType{
					ObjectType: types.ObjectType{
						AttrTypes: MistNacValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"msp_id": schema.StringAttribute{
				Computed: true,
				Default:  stringdefault.StaticString(""),
			},
			"mxtunnel_ids": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "when `interface`=`mxtunnel`, id of the Mist Tunnel",
				MarkdownDescription: "when `interface`=`mxtunnel`, id of the Mist Tunnel",
				Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
			},
			"mxtunnel_name": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting",
				MarkdownDescription: "when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting",
				Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
			},
			"no_static_dns": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to only allow client to use DNS that we’ve learned from DHCP response",
				MarkdownDescription: "whether to only allow client to use DNS that we’ve learned from DHCP response",
				Default:             booldefault.StaticBool(false),
			},
			"no_static_ip": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to only allow client that we’ve learned from DHCP exchange to talk",
				MarkdownDescription: "whether to only allow client that we’ve learned from DHCP exchange to talk",
				Default:             booldefault.StaticBool(false),
			},
			"org_id": schema.StringAttribute{
				Computed: true,
			},
			"portal": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"amazon_client_id": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "amazon OAuth2 client id. This is optional. If not provided, it will use a default one.",
						MarkdownDescription: "amazon OAuth2 client id. This is optional. If not provided, it will use a default one.",
						Default:             stringdefault.StaticString(""),
					},
					"amazon_client_secret": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "amazon OAuth2 client secret. If amazon_client_id was provided, provide a correspoinding value. Else leave blank.",
						MarkdownDescription: "amazon OAuth2 client secret. If amazon_client_id was provided, provide a correspoinding value. Else leave blank.",
						Default:             stringdefault.StaticString(""),
					},
					"amazon_email_domains": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
						MarkdownDescription: "Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
						Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
					},
					"amazon_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether amazon is enabled as a login method",
						MarkdownDescription: "whether amazon is enabled as a login method",
						Default:             booldefault.StaticBool(false),
					},
					"amazon_expire": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`",
						MarkdownDescription: "interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`",
						Default:             float64default.StaticFloat64(0),
					},
					"auth": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "authentication scheme",
						MarkdownDescription: "authentication scheme",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"none",
								"external",
								"sso",
							),
						},
						Default: stringdefault.StaticString("none"),
					},
					"azure_client_id": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Required if `azure_enabled`==`true`.\nAzure active directory app client id",
						MarkdownDescription: "Required if `azure_enabled`==`true`.\nAzure active directory app client id",
						Default:             stringdefault.StaticString(""),
					},
					"azure_client_secret": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Required if `azure_enabled`==`true`.\nAzure active directory app client secret",
						MarkdownDescription: "Required if `azure_enabled`==`true`.\nAzure active directory app client secret",
						Default:             stringdefault.StaticString(""),
					},
					"azure_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether Azure Active Directory is enabled as a login method",
						MarkdownDescription: "whether Azure Active Directory is enabled as a login method",
						Default:             booldefault.StaticBool(false),
					},
					"azure_expire": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`",
						MarkdownDescription: "interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`",
						Default:             float64default.StaticFloat64(0),
					},
					"azure_tenant_id": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Required if `azure_enabled`==`true`.\nAzure active directory tenant id.",
						MarkdownDescription: "Required if `azure_enabled`==`true`.\nAzure active directory tenant id.",
						Default:             stringdefault.StaticString(""),
					},
					"broadnet_password": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Sensitive:           true,
						Description:         "when `sms_provider`==`broadnet`",
						MarkdownDescription: "when `sms_provider`==`broadnet`",
						Default:             stringdefault.StaticString(""),
					},
					"broadnet_sid": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when `sms_provider`==`broadnet`",
						MarkdownDescription: "when `sms_provider`==`broadnet`",
						Default:             stringdefault.StaticString("MIST"),
					},
					"broadnet_user_id": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when `sms_provider`==`broadnet`",
						MarkdownDescription: "when `sms_provider`==`broadnet`",
						Default:             stringdefault.StaticString(""),
					},
					"bypass_when_cloud_down": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to bypass the guest portal when cloud not reachable (and apply the default policies)",
						MarkdownDescription: "whether to bypass the guest portal when cloud not reachable (and apply the default policies)",
						Default:             booldefault.StaticBool(false),
					},
					"clickatell_api_key": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when `sms_provider`==`clickatell`",
						MarkdownDescription: "when `sms_provider`==`clickatell`",
						Default:             stringdefault.StaticString(""),
					},
					"cross_site": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)",
						MarkdownDescription: "whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)",
						Default:             booldefault.StaticBool(false),
					},
					"email_enabled": schema.BoolAttribute{
						Optional:            true,
						Description:         "whether email (access code verification) is enabled as a login method",
						MarkdownDescription: "whether email (access code verification) is enabled as a login method",
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether guest portal is enabled",
						MarkdownDescription: "whether guest portal is enabled",
						Default:             booldefault.StaticBool(false),
					},
					"expire": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "how long to remain authorized, in minutes",
						MarkdownDescription: "how long to remain authorized, in minutes",
						Default:             float64default.StaticFloat64(1440),
					},
					"external_portal_url": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "external portal URL (e.g. https://host/url) where we can append our query parameters to",
						MarkdownDescription: "external portal URL (e.g. https://host/url) where we can append our query parameters to",
						Default:             stringdefault.StaticString(""),
					},
					"facebook_client_id": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Required if `facebook_enabled`==`true`.\nFacebook OAuth2 app id. This is optional. If not provided, it will use a default one.",
						MarkdownDescription: "Required if `facebook_enabled`==`true`.\nFacebook OAuth2 app id. This is optional. If not provided, it will use a default one.",
						Default:             stringdefault.StaticString(""),
					},
					"facebook_client_secret": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Required if `facebook_enabled`==`true`.\nFacebook OAuth2 app secret. If facebook_client_id was provided, provide a correspoinding value. Else leave blank.",
						MarkdownDescription: "Required if `facebook_enabled`==`true`.\nFacebook OAuth2 app secret. If facebook_client_id was provided, provide a correspoinding value. Else leave blank.",
						Default:             stringdefault.StaticString(""),
					},
					"facebook_email_domains": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
						MarkdownDescription: "Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
						Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
					},
					"facebook_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether facebook is enabled as a login method",
						MarkdownDescription: "whether facebook is enabled as a login method",
						Default:             booldefault.StaticBool(false),
					},
					"facebook_expire": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`",
						MarkdownDescription: "interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`",
						Default:             float64default.StaticFloat64(0),
					},
					"forward": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to forward the user to another URL after authorized",
						MarkdownDescription: "whether to forward the user to another URL after authorized",
						Default:             booldefault.StaticBool(false),
					},
					"forward_url": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "the URL to forward the user to",
						MarkdownDescription: "the URL to forward the user to",
						Default:             stringdefault.StaticString(""),
					},
					"google_client_id": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Google OAuth2 app id. This is optional. If not provided, it will use a default one.",
						MarkdownDescription: "Google OAuth2 app id. This is optional. If not provided, it will use a default one.",
						Default:             stringdefault.StaticString(""),
					},
					"google_client_secret": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Google OAuth2 app secret. If google_client_id was provided, provide a correspoinding value. Else leave blank.",
						MarkdownDescription: "Google OAuth2 app secret. If google_client_id was provided, provide a correspoinding value. Else leave blank.",
						Default:             stringdefault.StaticString(""),
					},
					"google_email_domains": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
						MarkdownDescription: "Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
						Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
					},
					"google_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether google is enabled as login method",
						MarkdownDescription: "whether google is enabled as login method",
						Default:             booldefault.StaticBool(false),
					},
					"google_expire": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "interval for which guest remains authorized using google auth (in minutes), if not provided, uses expire`",
						MarkdownDescription: "interval for which guest remains authorized using google auth (in minutes), if not provided, uses expire`",
						Default:             float64default.StaticFloat64(0),
					},
					"gupshup_password": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Sensitive:           true,
						Description:         "when `sms_provider`==`gupshup`",
						MarkdownDescription: "when `sms_provider`==`gupshup`",
						Default:             stringdefault.StaticString(""),
					},
					"gupshup_userid": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when `sms_provider`==`gupshup`",
						MarkdownDescription: "when `sms_provider`==`gupshup`",
						Default:             stringdefault.StaticString(""),
					},
					"microsoft_client_id": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.",
						MarkdownDescription: "microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.",
						Default:             stringdefault.StaticString(""),
					},
					"microsoft_client_secret": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a correspoinding value. Else leave blank.",
						MarkdownDescription: "microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a correspoinding value. Else leave blank.",
						Default:             stringdefault.StaticString(""),
					},
					"microsoft_email_domains": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
						MarkdownDescription: "Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
						Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
					},
					"microsoft_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether microsoft 365 is enabled as a login method",
						MarkdownDescription: "whether microsoft 365 is enabled as a login method",
						Default:             booldefault.StaticBool(false),
					},
					"microsoft_expire": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`",
						MarkdownDescription: "interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`",
						Default:             float64default.StaticFloat64(0),
					},
					"passphrase_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether password is enabled",
						MarkdownDescription: "whether password is enabled",
						Default:             booldefault.StaticBool(false),
					},
					"passphrase_expire": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`",
						MarkdownDescription: "interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`",
						Default:             float64default.StaticFloat64(0),
					},
					"password": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Sensitive:           true,
						Description:         "passphrase",
						MarkdownDescription: "passphrase",
						Default:             stringdefault.StaticString(""),
					},
					"portal_api_secret": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "api secret (auto-generated) that can be used to sign guest authorization requests",
						MarkdownDescription: "api secret (auto-generated) that can be used to sign guest authorization requests",
						Default:             stringdefault.StaticString(""),
					},
					"portal_image": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Url of portal background image",
						MarkdownDescription: "Url of portal background image",
						Default:             stringdefault.StaticString(""),
					},
					"portal_sso_url": schema.StringAttribute{
						Optional:            true,
						Description:         "for SAML, this is used as the ACS URL",
						MarkdownDescription: "for SAML, this is used as the ACS URL",
					},
					"predefined_sponsors_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`",
						MarkdownDescription: "whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`",
						Default:             booldefault.StaticBool(true),
					},
					"privacy": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(true),
					},
					"puzzel_password": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Sensitive:           true,
						Description:         "when `sms_provider`==`puzzel`",
						MarkdownDescription: "when `sms_provider`==`puzzel`",
						Default:             stringdefault.StaticString(""),
					},
					"puzzel_service_id": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when `sms_provider`==`puzzel`",
						MarkdownDescription: "when `sms_provider`==`puzzel`",
						Default:             stringdefault.StaticString(""),
					},
					"puzzel_username": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when `sms_provider`==`puzzel`",
						MarkdownDescription: "when `sms_provider`==`puzzel`",
						Default:             stringdefault.StaticString(""),
					},
					"sms_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether sms is enabled as a login method",
						MarkdownDescription: "whether sms is enabled as a login method",
						Default:             booldefault.StaticBool(false),
					},
					"sms_expire": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`",
						MarkdownDescription: "interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`",
						Default:             float64default.StaticFloat64(0),
					},
					"sms_message_format": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Default:  stringdefault.StaticString(""),
					},
					"sms_provider": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"manual",
								"twilio",
								"broadnet",
								"clickatell",
								"puzzel",
								"gupshup",
								"telstra",
							),
						},
						Default: stringdefault.StaticString("manual"),
					},
					"sponsor_auto_approve": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled",
						MarkdownDescription: "whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled",
						Default:             booldefault.StaticBool(false),
					},
					"sponsor_email_domains": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "list of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.",
						MarkdownDescription: "list of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.",
						Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
					},
					"sponsor_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether sponsor is enabled",
						MarkdownDescription: "whether sponsor is enabled",
						Default:             booldefault.StaticBool(false),
					},
					"sponsor_expire": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`",
						MarkdownDescription: "interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`",
						Default:             float64default.StaticFloat64(0),
					},
					"sponsor_link_validity_duration": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "how long to remain valid sponsored guest request approve/deny link received in email, in minutes.",
						MarkdownDescription: "how long to remain valid sponsored guest request approve/deny link received in email, in minutes.",
						Default:             int64default.StaticInt64(60),
					},
					"sponsor_notify_all": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.",
						MarkdownDescription: "whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.",
						Default:             booldefault.StaticBool(false),
					},
					"sponsor_status_notify": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "if enabled, guest will get email about sponsor's action (approve/deny)",
						MarkdownDescription: "if enabled, guest will get email about sponsor's action (approve/deny)",
						Default:             booldefault.StaticBool(false),
					},
					"sponsors": schema.MapAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "object of allowed sponsors email with name. Required if `sponsor_enabled` is `true` and `sponsor_email_domains` is empty.\nProperty key is the sponsor email, Property value is the sponsor name",
						MarkdownDescription: "object of allowed sponsors email with name. Required if `sponsor_enabled` is `true` and `sponsor_email_domains` is empty.\nProperty key is the sponsor email, Property value is the sponsor name",
					},
					"sso_default_role": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched",
						MarkdownDescription: "default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched",
						Default:             stringdefault.StaticString(""),
					},
					"sso_forced_role": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Default:  stringdefault.StaticString(""),
					},
					"sso_idp_cert": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "IDP Cert (used to verify the signed response)",
						MarkdownDescription: "IDP Cert (used to verify the signed response)",
						Default:             stringdefault.StaticString(""),
					},
					"sso_idp_sign_algo": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "signing algorithm for SAML Assertion",
						MarkdownDescription: "signing algorithm for SAML Assertion",
						Default:             stringdefault.StaticString(""),
					},
					"sso_idp_sso_url": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "IDP Single-Sign-On URL",
						MarkdownDescription: "IDP Single-Sign-On URL",
						Default:             stringdefault.StaticString(""),
					},
					"sso_issuer": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "IDP issuer URL",
						MarkdownDescription: "IDP issuer URL",
						Default:             stringdefault.StaticString(""),
					},
					"sso_nameid_format": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"email",
								"unspecified",
							),
						},
						Default: stringdefault.StaticString("email"),
					},
					"telstra_client_id": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when `sms_provider`==`telstra`, Client ID provided by Telstra",
						MarkdownDescription: "when `sms_provider`==`telstra`, Client ID provided by Telstra",
						Default:             stringdefault.StaticString(""),
					},
					"telstra_client_secret": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when `sms_provider`==`telstra`, Client secret provided by Telstra",
						MarkdownDescription: "when `sms_provider`==`telstra`, Client secret provided by Telstra",
						Default:             stringdefault.StaticString(""),
					},
					"twilio_auth_token": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when `sms_provider`==`twilio`, Auth token account with twilio account",
						MarkdownDescription: "when `sms_provider`==`twilio`, Auth token account with twilio account",
						Default:             stringdefault.StaticString(""),
					},
					"twilio_phone_number": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.",
						MarkdownDescription: "when `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.",
						Default:             stringdefault.StaticString(""),
					},
					"twilio_sid": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when `sms_provider`==`twilio`, Account SID provided by Twilio",
						MarkdownDescription: "when `sms_provider`==`twilio`, Account SID provided by Twilio",
						Default:             stringdefault.StaticString(""),
					},
				},
				CustomType: PortalType{
					ObjectType: types.ObjectType{
						AttrTypes: PortalValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "portal wlan settings",
				MarkdownDescription: "portal wlan settings",
			},
			"portal_allowed_hostnames": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "list of hostnames without http(s):// (matched by substring)",
				MarkdownDescription: "list of hostnames without http(s):// (matched by substring)",
			},
			"portal_allowed_subnets": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "list of CIDRs",
				MarkdownDescription: "list of CIDRs",
				Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
			},
			"portal_api_secret": schema.StringAttribute{
				Computed:            true,
				Description:         "api secret (auto-generated) that can be used to sign guest authorization requests",
				MarkdownDescription: "api secret (auto-generated) that can be used to sign guest authorization requests",
				Default:             stringdefault.StaticString(""),
			},
			"portal_denied_hostnames": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames",
				MarkdownDescription: "list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames",
				Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
			},
			"portal_image": schema.StringAttribute{
				Computed:            true,
				Description:         "Url of portal background image",
				MarkdownDescription: "Url of portal background image",
				Default:             stringdefault.StaticString(""),
			},
			"portal_sso_url": schema.StringAttribute{
				Computed: true,
			},
			"portal_template_url": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "N.B portal_template will be forked out of wlan objects soon. To fetch portal_template, please query portal_template_url. To update portal_template, use Wlan Portal Template.",
				MarkdownDescription: "N.B portal_template will be forked out of wlan objects soon. To fetch portal_template, please query portal_template_url. To update portal_template, use Wlan Portal Template.",
				Default:             stringdefault.StaticString(""),
			},
			"qos": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"class": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"background",
								"best_effort",
								"video",
								"voice",
							),
						},
						Default: stringdefault.StaticString("best_effort"),
					},
					"overwrite": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to overwrite QoS",
						MarkdownDescription: "whether to overwrite QoS",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: QosType{
					ObjectType: types.ObjectType{
						AttrTypes: QosValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"radsec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"coa_enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
					},
					"idle_timeout": schema.Int64Attribute{
						Optional: true,
					},
					"mxcluster_ids": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids.\nOrg mxedge(s) identified by mxcluster_ids",
						MarkdownDescription: "To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids.\nOrg mxedge(s) identified by mxcluster_ids",
					},
					"proxy_hosts": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "default is site.mxedge.radsec.proxy_hosts which must be a superset of all wlans[*].radsec.proxy_hosts\nwhen radsec.proxy_hosts are not used, tunnel peers (org or site mxedges) are used irrespective of use_site_mxedge",
						MarkdownDescription: "default is site.mxedge.radsec.proxy_hosts which must be a superset of all wlans[*].radsec.proxy_hosts\nwhen radsec.proxy_hosts are not used, tunnel peers (org or site mxedges) are used irrespective of use_site_mxedge",
					},
					"server_name": schema.StringAttribute{
						Optional:            true,
						Description:         "name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.",
						MarkdownDescription: "name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.",
					},
					"servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Optional: true,
								},
								"port": schema.Int64Attribute{
									Optional: true,
								},
							},
							CustomType: ServersType{
								ObjectType: types.ObjectType{
									AttrTypes: ServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "List of Radsec Servers. Only if not Mist Edge.",
						MarkdownDescription: "List of Radsec Servers. Only if not Mist Edge.",
						Validators: []validator.List{
							listvalidator.UniqueValues(),
						},
					},
					"use_mxedge": schema.BoolAttribute{
						Optional:            true,
						Description:         "use mxedge(s) as radsecproxy",
						MarkdownDescription: "use mxedge(s) as radsecproxy",
					},
					"use_site_mxedge": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "To use Site mxedges when this WLAN does not use mxtunnel",
						MarkdownDescription: "To use Site mxedges when this WLAN does not use mxtunnel",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: RadsecType{
					ObjectType: types.ObjectType{
						AttrTypes: RadsecValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Radsec settings",
				MarkdownDescription: "Radsec settings",
			},
			"roam_mode": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"none",
						"OKC",
						"11r",
					),
				},
				Default: stringdefault.StaticString("none"),
			},
			"schedule": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"hours": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"fri": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
							"mon": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
							"sat": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
							"sun": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
							"thu": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
							"tue": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
							"wed": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
						},
						CustomType: HoursType{
							ObjectType: types.ObjectType{
								AttrTypes: HoursValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). \n\n**Note**: If the dow is not defined then it’s treated as 00:00-23:59.",
						MarkdownDescription: "hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). \n\n**Note**: If the dow is not defined then it’s treated as 00:00-23:59.",
					},
				},
				CustomType: ScheduleType{
					ObjectType: types.ObjectType{
						AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "WLAN operating schedule, default is disabled",
				MarkdownDescription: "WLAN operating schedule, default is disabled",
			},
			"site_id": schema.StringAttribute{
				Required: true,
			},
			"sle_excluded": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to exclude this WLAN from SLE metrics",
				MarkdownDescription: "whether to exclude this WLAN from SLE metrics",
				Default:             booldefault.StaticBool(false),
			},
			"ssid": schema.StringAttribute{
				Required:            true,
				Description:         "the name of the SSID",
				MarkdownDescription: "the name of the SSID",
			},
			"thumbnail": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Url of portal background image thumbnail",
				MarkdownDescription: "Url of portal background image thumbnail",
				Default:             stringdefault.StaticString(""),
			},
			"use_eapol_v1": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices",
				MarkdownDescription: "if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices",
				Default:             booldefault.StaticBool(false),
			},
			"vlan_enabled": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "if vlan tagging is enabled",
				MarkdownDescription: "if vlan tagging is enabled",
				Default:             booldefault.StaticBool(false),
			},
			"vlan_id": schema.Int64Attribute{
				Optional: true,
				Computed: true,
				Validators: []validator.Int64{
					int64validator.Between(1, 4094),
				},
			},
			"vlan_ids": schema.ListAttribute{
				ElementType:         types.Int64Type,
				Optional:            true,
				Computed:            true,
				Description:         "vlan_ids to use when there’s no match from RA",
				MarkdownDescription: "vlan_ids to use when there’s no match from RA",
				Default:             listdefault.StaticValue(types.ListValueMust(types.Int64Type, []attr.Value{})),
			},
			"vlan_pooling": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "vlan pooling allows AP to place client on different VLAN using a deterministic algorithm",
				MarkdownDescription: "vlan pooling allows AP to place client on different VLAN using a deterministic algorithm",
				Default:             booldefault.StaticBool(false),
			},
			"wlan_limit_down": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "kbps",
				MarkdownDescription: "kbps",
				Default:             int64default.StaticInt64(0),
			},
			"wlan_limit_down_enabled": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "if downlink limiting for whole wlan is enabled",
				MarkdownDescription: "if downlink limiting for whole wlan is enabled",
				Default:             booldefault.StaticBool(false),
			},
			"wlan_limit_up": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "kbps",
				MarkdownDescription: "kbps",
				Default:             int64default.StaticInt64(0),
			},
			"wlan_limit_up_enabled": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "if uplink limiting for whole wlan is enabled",
				MarkdownDescription: "if uplink limiting for whole wlan is enabled",
				Default:             booldefault.StaticBool(false),
			},
			"wxtag_ids": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "list of wxtag_ids",
				MarkdownDescription: "list of wxtag_ids",
				Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
			},
			"wxtunnel_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "when `interface`=`wxtunnel`, id of the WXLAN Tunnel",
				MarkdownDescription: "when `interface`=`wxtunnel`, id of the WXLAN Tunnel",
				Default:             stringdefault.StaticString(""),
			},
			"wxtunnel_remote_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "when `interface`=`wxtunnel`, remote tunnel identifier",
				MarkdownDescription: "when `interface`=`wxtunnel`, remote tunnel identifier",
				Default:             stringdefault.StaticString(""),
			},
		},
	}
}

type SiteWlanModel struct {
	AcctImmediateUpdate                types.Bool              `tfsdk:"acct_immediate_update"`
	AcctInterimInterval                types.Int64             `tfsdk:"acct_interim_interval"`
	AcctServers                        types.List              `tfsdk:"acct_servers"`
	Airwatch                           AirwatchValue           `tfsdk:"airwatch"`
	AllowIpv6Ndp                       types.Bool              `tfsdk:"allow_ipv6_ndp"`
	AllowMdns                          types.Bool              `tfsdk:"allow_mdns"`
	AllowSsdp                          types.Bool              `tfsdk:"allow_ssdp"`
	ApIds                              types.List              `tfsdk:"ap_ids"`
	AppLimit                           AppLimitValue           `tfsdk:"app_limit"`
	AppQos                             AppQosValue             `tfsdk:"app_qos"`
	ApplyTo                            types.String            `tfsdk:"apply_to"`
	ArpFilter                          types.Bool              `tfsdk:"arp_filter"`
	Auth                               AuthValue               `tfsdk:"auth"`
	AuthServerSelection                types.String            `tfsdk:"auth_server_selection"`
	AuthServers                        types.List              `tfsdk:"auth_servers"`
	AuthServersNasId                   types.String            `tfsdk:"auth_servers_nas_id"`
	AuthServersNasIp                   types.String            `tfsdk:"auth_servers_nas_ip"`
	AuthServersRetries                 types.Int64             `tfsdk:"auth_servers_retries"`
	AuthServersTimeout                 types.Int64             `tfsdk:"auth_servers_timeout"`
	BandSteer                          types.Bool              `tfsdk:"band_steer"`
	BandSteerForceBand5                types.Bool              `tfsdk:"band_steer_force_band5"`
	Bands                              types.List              `tfsdk:"bands"`
	BlockBlacklistClients              types.Bool              `tfsdk:"block_blacklist_clients"`
	Bonjour                            BonjourValue            `tfsdk:"bonjour"`
	CiscoCwa                           CiscoCwaValue           `tfsdk:"cisco_cwa"`
	ClientLimitDown                    types.Int64             `tfsdk:"client_limit_down"`
	ClientLimitDownEnabled             types.Bool              `tfsdk:"client_limit_down_enabled"`
	ClientLimitUp                      types.Int64             `tfsdk:"client_limit_up"`
	ClientLimitUpEnabled               types.Bool              `tfsdk:"client_limit_up_enabled"`
	CoaServers                         types.List              `tfsdk:"coa_servers"`
	Disable11ax                        types.Bool              `tfsdk:"disable_11ax"`
	DisableHtVhtRates                  types.Bool              `tfsdk:"disable_ht_vht_rates"`
	DisableUapsd                       types.Bool              `tfsdk:"disable_uapsd"`
	DisableV1RoamNotify                types.Bool              `tfsdk:"disable_v1_roam_notify"`
	DisableV2RoamNotify                types.Bool              `tfsdk:"disable_v2_roam_notify"`
	DisableWmm                         types.Bool              `tfsdk:"disable_wmm"`
	DnsServerRewrite                   DnsServerRewriteValue   `tfsdk:"dns_server_rewrite"`
	Dtim                               types.Int64             `tfsdk:"dtim"`
	DynamicPsk                         DynamicPskValue         `tfsdk:"dynamic_psk"`
	DynamicVlan                        DynamicVlanValue        `tfsdk:"dynamic_vlan"`
	EnableLocalKeycaching              types.Bool              `tfsdk:"enable_local_keycaching"`
	EnableWirelessBridging             types.Bool              `tfsdk:"enable_wireless_bridging"`
	EnableWirelessBridgingDhcpTracking types.Bool              `tfsdk:"enable_wireless_bridging_dhcp_tracking"`
	Enabled                            types.Bool              `tfsdk:"enabled"`
	FastDot1xTimers                    types.Bool              `tfsdk:"fast_dot1x_timers"`
	HideSsid                           types.Bool              `tfsdk:"hide_ssid"`
	HostnameIe                         types.Bool              `tfsdk:"hostname_ie"`
	Hotspot20                          Hotspot20Value          `tfsdk:"hotspot20"`
	Id                                 types.String            `tfsdk:"id"`
	InjectDhcpOption82                 InjectDhcpOption82Value `tfsdk:"inject_dhcp_option_82"`
	Interface                          types.String            `tfsdk:"interface"`
	Isolation                          types.Bool              `tfsdk:"isolation"`
	L2Isolation                        types.Bool              `tfsdk:"l2_isolation"`
	LegacyOverds                       types.Bool              `tfsdk:"legacy_overds"`
	LimitBcast                         types.Bool              `tfsdk:"limit_bcast"`
	LimitProbeResponse                 types.Bool              `tfsdk:"limit_probe_response"`
	MaxIdletime                        types.Int64             `tfsdk:"max_idletime"`
	MistNac                            MistNacValue            `tfsdk:"mist_nac"`
	MspId                              types.String            `tfsdk:"msp_id"`
	MxtunnelIds                        types.List              `tfsdk:"mxtunnel_ids"`
	MxtunnelName                       types.List              `tfsdk:"mxtunnel_name"`
	NoStaticDns                        types.Bool              `tfsdk:"no_static_dns"`
	NoStaticIp                         types.Bool              `tfsdk:"no_static_ip"`
	OrgId                              types.String            `tfsdk:"org_id"`
	Portal                             PortalValue             `tfsdk:"portal"`
	PortalAllowedHostnames             types.List              `tfsdk:"portal_allowed_hostnames"`
	PortalAllowedSubnets               types.List              `tfsdk:"portal_allowed_subnets"`
	PortalApiSecret                    types.String            `tfsdk:"portal_api_secret"`
	PortalDeniedHostnames              types.List              `tfsdk:"portal_denied_hostnames"`
	PortalImage                        types.String            `tfsdk:"portal_image"`
	PortalSsoUrl                       types.String            `tfsdk:"portal_sso_url"`
	PortalTemplateUrl                  types.String            `tfsdk:"portal_template_url"`
	Qos                                QosValue                `tfsdk:"qos"`
	Radsec                             RadsecValue             `tfsdk:"radsec"`
	RoamMode                           types.String            `tfsdk:"roam_mode"`
	Schedule                           ScheduleValue           `tfsdk:"schedule"`
	SiteId                             types.String            `tfsdk:"site_id"`
	SleExcluded                        types.Bool              `tfsdk:"sle_excluded"`
	Ssid                               types.String            `tfsdk:"ssid"`
	Thumbnail                          types.String            `tfsdk:"thumbnail"`
	UseEapolV1                         types.Bool              `tfsdk:"use_eapol_v1"`
	VlanEnabled                        types.Bool              `tfsdk:"vlan_enabled"`
	VlanId                             types.Int64             `tfsdk:"vlan_id"`
	VlanIds                            types.List              `tfsdk:"vlan_ids"`
	VlanPooling                        types.Bool              `tfsdk:"vlan_pooling"`
	WlanLimitDown                      types.Int64             `tfsdk:"wlan_limit_down"`
	WlanLimitDownEnabled               types.Bool              `tfsdk:"wlan_limit_down_enabled"`
	WlanLimitUp                        types.Int64             `tfsdk:"wlan_limit_up"`
	WlanLimitUpEnabled                 types.Bool              `tfsdk:"wlan_limit_up_enabled"`
	WxtagIds                           types.List              `tfsdk:"wxtag_ids"`
	WxtunnelId                         types.String            `tfsdk:"wxtunnel_id"`
	WxtunnelRemoteId                   types.String            `tfsdk:"wxtunnel_remote_id"`
}

var _ basetypes.ObjectTypable = AcctServersType{}

type AcctServersType struct {
	basetypes.ObjectType
}

func (t AcctServersType) Equal(o attr.Type) bool {
	other, ok := o.(AcctServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AcctServersType) String() string {
	return "AcctServersType"
}

func (t AcctServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueNull() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAcctServersValueUnknown() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAcctServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AcctServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, a missing attribute value was detected. "+
					"A AcctServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AcctServersValue Attribute Type",
				"While creating a AcctServersValue value, an invalid attribute value was detected. "+
					"A AcctServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, an extra attribute value was detected. "+
					"A AcctServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AcctServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AcctServersValue {
	object, diags := NewAcctServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAcctServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AcctServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAcctServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAcctServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAcctServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAcctServersValueMust(AcctServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AcctServersType) ValueType(ctx context.Context) attr.Value {
	return AcctServersValue{}
}

var _ basetypes.ObjectValuable = AcctServersValue{}

type AcctServersValue struct {
	Host           basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat  basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek     basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack    basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port           basetypes.Int64Value  `tfsdk:"port"`
	Secret         basetypes.StringValue `tfsdk:"secret"`
	state          attr.ValueState
}

func (v AcctServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AcctServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AcctServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AcctServersValue) String() string {
	return "AcctServersValue"
}

func (v AcctServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":            v.Host,
			"keywrap_enabled": v.KeywrapEnabled,
			"keywrap_format":  v.KeywrapFormat,
			"keywrap_kek":     v.KeywrapKek,
			"keywrap_mack":    v.KeywrapMack,
			"port":            v.Port,
			"secret":          v.Secret,
		})

	return objVal, diags
}

func (v AcctServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AcctServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AcctServersValue) Type(ctx context.Context) attr.Type {
	return AcctServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AcctServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AirwatchType{}

type AirwatchType struct {
	basetypes.ObjectType
}

func (t AirwatchType) Equal(o attr.Type) bool {
	other, ok := o.(AirwatchType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AirwatchType) String() string {
	return "AirwatchType"
}

func (t AirwatchType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return nil, diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	consoleUrlAttribute, ok := attributes["console_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`console_url is missing from object`)

		return nil, diags
	}

	consoleUrlVal, ok := consoleUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`console_url expected to be basetypes.StringValue, was: %T`, consoleUrlAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AirwatchValue{
		ApiKey:     apiKeyVal,
		ConsoleUrl: consoleUrlVal,
		Enabled:    enabledVal,
		Password:   passwordVal,
		Username:   usernameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAirwatchValueNull() AirwatchValue {
	return AirwatchValue{
		state: attr.ValueStateNull,
	}
}

func NewAirwatchValueUnknown() AirwatchValue {
	return AirwatchValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAirwatchValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AirwatchValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AirwatchValue Attribute Value",
				"While creating a AirwatchValue value, a missing attribute value was detected. "+
					"A AirwatchValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AirwatchValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AirwatchValue Attribute Type",
				"While creating a AirwatchValue value, an invalid attribute value was detected. "+
					"A AirwatchValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AirwatchValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AirwatchValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AirwatchValue Attribute Value",
				"While creating a AirwatchValue value, an extra attribute value was detected. "+
					"A AirwatchValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AirwatchValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAirwatchValueUnknown(), diags
	}

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return NewAirwatchValueUnknown(), diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	consoleUrlAttribute, ok := attributes["console_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`console_url is missing from object`)

		return NewAirwatchValueUnknown(), diags
	}

	consoleUrlVal, ok := consoleUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`console_url expected to be basetypes.StringValue, was: %T`, consoleUrlAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAirwatchValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewAirwatchValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewAirwatchValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewAirwatchValueUnknown(), diags
	}

	return AirwatchValue{
		ApiKey:     apiKeyVal,
		ConsoleUrl: consoleUrlVal,
		Enabled:    enabledVal,
		Password:   passwordVal,
		Username:   usernameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAirwatchValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AirwatchValue {
	object, diags := NewAirwatchValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAirwatchValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AirwatchType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAirwatchValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAirwatchValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAirwatchValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAirwatchValueMust(AirwatchValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AirwatchType) ValueType(ctx context.Context) attr.Value {
	return AirwatchValue{}
}

var _ basetypes.ObjectValuable = AirwatchValue{}

type AirwatchValue struct {
	ApiKey     basetypes.StringValue `tfsdk:"api_key"`
	ConsoleUrl basetypes.StringValue `tfsdk:"console_url"`
	Enabled    basetypes.BoolValue   `tfsdk:"enabled"`
	Password   basetypes.StringValue `tfsdk:"password"`
	Username   basetypes.StringValue `tfsdk:"username"`
	state      attr.ValueState
}

func (v AirwatchValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["console_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_key"] = val

		val, err = v.ConsoleUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["console_url"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AirwatchValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AirwatchValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AirwatchValue) String() string {
	return "AirwatchValue"
}

func (v AirwatchValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"api_key":     basetypes.StringType{},
		"console_url": basetypes.StringType{},
		"enabled":     basetypes.BoolType{},
		"password":    basetypes.StringType{},
		"username":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_key":     v.ApiKey,
			"console_url": v.ConsoleUrl,
			"enabled":     v.Enabled,
			"password":    v.Password,
			"username":    v.Username,
		})

	return objVal, diags
}

func (v AirwatchValue) Equal(o attr.Value) bool {
	other, ok := o.(AirwatchValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiKey.Equal(other.ApiKey) {
		return false
	}

	if !v.ConsoleUrl.Equal(other.ConsoleUrl) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v AirwatchValue) Type(ctx context.Context) attr.Type {
	return AirwatchType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AirwatchValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_key":     basetypes.StringType{},
		"console_url": basetypes.StringType{},
		"enabled":     basetypes.BoolType{},
		"password":    basetypes.StringType{},
		"username":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AppLimitType{}

type AppLimitType struct {
	basetypes.ObjectType
}

func (t AppLimitType) Equal(o attr.Type) bool {
	other, ok := o.(AppLimitType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AppLimitType) String() string {
	return "AppLimitType"
}

func (t AppLimitType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appsAttribute, ok := attributes["apps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apps is missing from object`)

		return nil, diags
	}

	appsVal, ok := appsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apps expected to be basetypes.MapValue, was: %T`, appsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	wxtagIdsAttribute, ok := attributes["wxtag_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtag_ids is missing from object`)

		return nil, diags
	}

	wxtagIdsVal, ok := wxtagIdsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtag_ids expected to be basetypes.MapValue, was: %T`, wxtagIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AppLimitValue{
		Apps:     appsVal,
		Enabled:  enabledVal,
		WxtagIds: wxtagIdsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAppLimitValueNull() AppLimitValue {
	return AppLimitValue{
		state: attr.ValueStateNull,
	}
}

func NewAppLimitValueUnknown() AppLimitValue {
	return AppLimitValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAppLimitValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AppLimitValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AppLimitValue Attribute Value",
				"While creating a AppLimitValue value, a missing attribute value was detected. "+
					"A AppLimitValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppLimitValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AppLimitValue Attribute Type",
				"While creating a AppLimitValue value, an invalid attribute value was detected. "+
					"A AppLimitValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppLimitValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AppLimitValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AppLimitValue Attribute Value",
				"While creating a AppLimitValue value, an extra attribute value was detected. "+
					"A AppLimitValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AppLimitValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAppLimitValueUnknown(), diags
	}

	appsAttribute, ok := attributes["apps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apps is missing from object`)

		return NewAppLimitValueUnknown(), diags
	}

	appsVal, ok := appsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apps expected to be basetypes.MapValue, was: %T`, appsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAppLimitValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	wxtagIdsAttribute, ok := attributes["wxtag_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtag_ids is missing from object`)

		return NewAppLimitValueUnknown(), diags
	}

	wxtagIdsVal, ok := wxtagIdsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtag_ids expected to be basetypes.MapValue, was: %T`, wxtagIdsAttribute))
	}

	if diags.HasError() {
		return NewAppLimitValueUnknown(), diags
	}

	return AppLimitValue{
		Apps:     appsVal,
		Enabled:  enabledVal,
		WxtagIds: wxtagIdsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAppLimitValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AppLimitValue {
	object, diags := NewAppLimitValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAppLimitValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AppLimitType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAppLimitValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAppLimitValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAppLimitValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAppLimitValueMust(AppLimitValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AppLimitType) ValueType(ctx context.Context) attr.Value {
	return AppLimitValue{}
}

var _ basetypes.ObjectValuable = AppLimitValue{}

type AppLimitValue struct {
	Apps     basetypes.MapValue  `tfsdk:"apps"`
	Enabled  basetypes.BoolValue `tfsdk:"enabled"`
	WxtagIds basetypes.MapValue  `tfsdk:"wxtag_ids"`
	state    attr.ValueState
}

func (v AppLimitValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["apps"] = basetypes.MapType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["wxtag_ids"] = basetypes.MapType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Apps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["apps"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.WxtagIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wxtag_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AppLimitValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AppLimitValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AppLimitValue) String() string {
	return "AppLimitValue"
}

func (v AppLimitValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	appsVal, d := types.MapValue(types.Int64Type, v.Apps.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"apps": basetypes.MapType{
				ElemType: types.Int64Type,
			},
			"enabled": basetypes.BoolType{},
			"wxtag_ids": basetypes.MapType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	wxtagIdsVal, d := types.MapValue(types.Int64Type, v.WxtagIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"apps": basetypes.MapType{
				ElemType: types.Int64Type,
			},
			"enabled": basetypes.BoolType{},
			"wxtag_ids": basetypes.MapType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"apps": basetypes.MapType{
			ElemType: types.Int64Type,
		},
		"enabled": basetypes.BoolType{},
		"wxtag_ids": basetypes.MapType{
			ElemType: types.Int64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"apps":      appsVal,
			"enabled":   v.Enabled,
			"wxtag_ids": wxtagIdsVal,
		})

	return objVal, diags
}

func (v AppLimitValue) Equal(o attr.Value) bool {
	other, ok := o.(AppLimitValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Apps.Equal(other.Apps) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.WxtagIds.Equal(other.WxtagIds) {
		return false
	}

	return true
}

func (v AppLimitValue) Type(ctx context.Context) attr.Type {
	return AppLimitType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AppLimitValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"apps": basetypes.MapType{
			ElemType: types.Int64Type,
		},
		"enabled": basetypes.BoolType{},
		"wxtag_ids": basetypes.MapType{
			ElemType: types.Int64Type,
		},
	}
}

var _ basetypes.ObjectTypable = AppQosType{}

type AppQosType struct {
	basetypes.ObjectType
}

func (t AppQosType) Equal(o attr.Type) bool {
	other, ok := o.(AppQosType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AppQosType) String() string {
	return "AppQosType"
}

func (t AppQosType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appsAttribute, ok := attributes["apps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apps is missing from object`)

		return nil, diags
	}

	appsVal, ok := appsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apps expected to be basetypes.MapValue, was: %T`, appsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	othersAttribute, ok := attributes["others"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`others is missing from object`)

		return nil, diags
	}

	othersVal, ok := othersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`others expected to be basetypes.ListValue, was: %T`, othersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AppQosValue{
		Apps:    appsVal,
		Enabled: enabledVal,
		Others:  othersVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAppQosValueNull() AppQosValue {
	return AppQosValue{
		state: attr.ValueStateNull,
	}
}

func NewAppQosValueUnknown() AppQosValue {
	return AppQosValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAppQosValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AppQosValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AppQosValue Attribute Value",
				"While creating a AppQosValue value, a missing attribute value was detected. "+
					"A AppQosValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppQosValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AppQosValue Attribute Type",
				"While creating a AppQosValue value, an invalid attribute value was detected. "+
					"A AppQosValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppQosValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AppQosValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AppQosValue Attribute Value",
				"While creating a AppQosValue value, an extra attribute value was detected. "+
					"A AppQosValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AppQosValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAppQosValueUnknown(), diags
	}

	appsAttribute, ok := attributes["apps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apps is missing from object`)

		return NewAppQosValueUnknown(), diags
	}

	appsVal, ok := appsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apps expected to be basetypes.MapValue, was: %T`, appsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAppQosValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	othersAttribute, ok := attributes["others"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`others is missing from object`)

		return NewAppQosValueUnknown(), diags
	}

	othersVal, ok := othersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`others expected to be basetypes.ListValue, was: %T`, othersAttribute))
	}

	if diags.HasError() {
		return NewAppQosValueUnknown(), diags
	}

	return AppQosValue{
		Apps:    appsVal,
		Enabled: enabledVal,
		Others:  othersVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAppQosValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AppQosValue {
	object, diags := NewAppQosValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAppQosValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AppQosType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAppQosValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAppQosValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAppQosValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAppQosValueMust(AppQosValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AppQosType) ValueType(ctx context.Context) attr.Value {
	return AppQosValue{}
}

var _ basetypes.ObjectValuable = AppQosValue{}

type AppQosValue struct {
	Apps    basetypes.MapValue  `tfsdk:"apps"`
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	Others  basetypes.ListValue `tfsdk:"others"`
	state   attr.ValueState
}

func (v AppQosValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["apps"] = basetypes.MapType{
		ElemType: AppsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["others"] = basetypes.ListType{
		ElemType: OthersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Apps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["apps"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Others.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["others"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AppQosValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AppQosValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AppQosValue) String() string {
	return "AppQosValue"
}

func (v AppQosValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	apps := types.MapValueMust(
		AppsType{
			basetypes.ObjectType{
				AttrTypes: AppsValue{}.AttributeTypes(ctx),
			},
		},
		v.Apps.Elements(),
	)

	if v.Apps.IsNull() {
		apps = types.MapNull(
			AppsType{
				basetypes.ObjectType{
					AttrTypes: AppsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Apps.IsUnknown() {
		apps = types.MapUnknown(
			AppsType{
				basetypes.ObjectType{
					AttrTypes: AppsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	others := types.ListValueMust(
		OthersType{
			basetypes.ObjectType{
				AttrTypes: OthersValue{}.AttributeTypes(ctx),
			},
		},
		v.Others.Elements(),
	)

	if v.Others.IsNull() {
		others = types.ListNull(
			OthersType{
				basetypes.ObjectType{
					AttrTypes: OthersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Others.IsUnknown() {
		others = types.ListUnknown(
			OthersType{
				basetypes.ObjectType{
					AttrTypes: OthersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"apps": basetypes.MapType{
			ElemType: AppsValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
		"others": basetypes.ListType{
			ElemType: OthersValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"apps":    apps,
			"enabled": v.Enabled,
			"others":  others,
		})

	return objVal, diags
}

func (v AppQosValue) Equal(o attr.Value) bool {
	other, ok := o.(AppQosValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Apps.Equal(other.Apps) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Others.Equal(other.Others) {
		return false
	}

	return true
}

func (v AppQosValue) Type(ctx context.Context) attr.Type {
	return AppQosType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AppQosValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"apps": basetypes.MapType{
			ElemType: AppsValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
		"others": basetypes.ListType{
			ElemType: OthersValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AppsType{}

type AppsType struct {
	basetypes.ObjectType
}

func (t AppsType) Equal(o attr.Type) bool {
	other, ok := o.(AppsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AppsType) String() string {
	return "AppsType"
}

func (t AppsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return nil, diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.Int64Value, was: %T`, dscpAttribute))
	}

	dstSubnetAttribute, ok := attributes["dst_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_subnet is missing from object`)

		return nil, diags
	}

	dstSubnetVal, ok := dstSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_subnet expected to be basetypes.StringValue, was: %T`, dstSubnetAttribute))
	}

	srcSubnetAttribute, ok := attributes["src_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_subnet is missing from object`)

		return nil, diags
	}

	srcSubnetVal, ok := srcSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_subnet expected to be basetypes.StringValue, was: %T`, srcSubnetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AppsValue{
		Dscp:      dscpVal,
		DstSubnet: dstSubnetVal,
		SrcSubnet: srcSubnetVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAppsValueNull() AppsValue {
	return AppsValue{
		state: attr.ValueStateNull,
	}
}

func NewAppsValueUnknown() AppsValue {
	return AppsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAppsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AppsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AppsValue Attribute Value",
				"While creating a AppsValue value, a missing attribute value was detected. "+
					"A AppsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AppsValue Attribute Type",
				"While creating a AppsValue value, an invalid attribute value was detected. "+
					"A AppsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AppsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AppsValue Attribute Value",
				"While creating a AppsValue value, an extra attribute value was detected. "+
					"A AppsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AppsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAppsValueUnknown(), diags
	}

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return NewAppsValueUnknown(), diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.Int64Value, was: %T`, dscpAttribute))
	}

	dstSubnetAttribute, ok := attributes["dst_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_subnet is missing from object`)

		return NewAppsValueUnknown(), diags
	}

	dstSubnetVal, ok := dstSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_subnet expected to be basetypes.StringValue, was: %T`, dstSubnetAttribute))
	}

	srcSubnetAttribute, ok := attributes["src_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_subnet is missing from object`)

		return NewAppsValueUnknown(), diags
	}

	srcSubnetVal, ok := srcSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_subnet expected to be basetypes.StringValue, was: %T`, srcSubnetAttribute))
	}

	if diags.HasError() {
		return NewAppsValueUnknown(), diags
	}

	return AppsValue{
		Dscp:      dscpVal,
		DstSubnet: dstSubnetVal,
		SrcSubnet: srcSubnetVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAppsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AppsValue {
	object, diags := NewAppsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAppsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AppsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAppsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAppsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAppsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAppsValueMust(AppsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AppsType) ValueType(ctx context.Context) attr.Value {
	return AppsValue{}
}

var _ basetypes.ObjectValuable = AppsValue{}

type AppsValue struct {
	Dscp      basetypes.Int64Value  `tfsdk:"dscp"`
	DstSubnet basetypes.StringValue `tfsdk:"dst_subnet"`
	SrcSubnet basetypes.StringValue `tfsdk:"src_subnet"`
	state     attr.ValueState
}

func (v AppsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["dscp"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dst_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["src_subnet"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Dscp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dscp"] = val

		val, err = v.DstSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dst_subnet"] = val

		val, err = v.SrcSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["src_subnet"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AppsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AppsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AppsValue) String() string {
	return "AppsValue"
}

func (v AppsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"dscp":       basetypes.Int64Type{},
		"dst_subnet": basetypes.StringType{},
		"src_subnet": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dscp":       v.Dscp,
			"dst_subnet": v.DstSubnet,
			"src_subnet": v.SrcSubnet,
		})

	return objVal, diags
}

func (v AppsValue) Equal(o attr.Value) bool {
	other, ok := o.(AppsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dscp.Equal(other.Dscp) {
		return false
	}

	if !v.DstSubnet.Equal(other.DstSubnet) {
		return false
	}

	if !v.SrcSubnet.Equal(other.SrcSubnet) {
		return false
	}

	return true
}

func (v AppsValue) Type(ctx context.Context) attr.Type {
	return AppsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AppsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dscp":       basetypes.Int64Type{},
		"dst_subnet": basetypes.StringType{},
		"src_subnet": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OthersType{}

type OthersType struct {
	basetypes.ObjectType
}

func (t OthersType) Equal(o attr.Type) bool {
	other, ok := o.(OthersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OthersType) String() string {
	return "OthersType"
}

func (t OthersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return nil, diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.Int64Value, was: %T`, dscpAttribute))
	}

	dstSubnetAttribute, ok := attributes["dst_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_subnet is missing from object`)

		return nil, diags
	}

	dstSubnetVal, ok := dstSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_subnet expected to be basetypes.StringValue, was: %T`, dstSubnetAttribute))
	}

	portRangesAttribute, ok := attributes["port_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_ranges is missing from object`)

		return nil, diags
	}

	portRangesVal, ok := portRangesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_ranges expected to be basetypes.StringValue, was: %T`, portRangesAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	srcSubnetAttribute, ok := attributes["src_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_subnet is missing from object`)

		return nil, diags
	}

	srcSubnetVal, ok := srcSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_subnet expected to be basetypes.StringValue, was: %T`, srcSubnetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OthersValue{
		Dscp:       dscpVal,
		DstSubnet:  dstSubnetVal,
		PortRanges: portRangesVal,
		Protocol:   protocolVal,
		SrcSubnet:  srcSubnetVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewOthersValueNull() OthersValue {
	return OthersValue{
		state: attr.ValueStateNull,
	}
}

func NewOthersValueUnknown() OthersValue {
	return OthersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOthersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OthersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OthersValue Attribute Value",
				"While creating a OthersValue value, a missing attribute value was detected. "+
					"A OthersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OthersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OthersValue Attribute Type",
				"While creating a OthersValue value, an invalid attribute value was detected. "+
					"A OthersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OthersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OthersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OthersValue Attribute Value",
				"While creating a OthersValue value, an extra attribute value was detected. "+
					"A OthersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OthersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOthersValueUnknown(), diags
	}

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return NewOthersValueUnknown(), diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.Int64Value, was: %T`, dscpAttribute))
	}

	dstSubnetAttribute, ok := attributes["dst_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_subnet is missing from object`)

		return NewOthersValueUnknown(), diags
	}

	dstSubnetVal, ok := dstSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_subnet expected to be basetypes.StringValue, was: %T`, dstSubnetAttribute))
	}

	portRangesAttribute, ok := attributes["port_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_ranges is missing from object`)

		return NewOthersValueUnknown(), diags
	}

	portRangesVal, ok := portRangesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_ranges expected to be basetypes.StringValue, was: %T`, portRangesAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewOthersValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	srcSubnetAttribute, ok := attributes["src_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_subnet is missing from object`)

		return NewOthersValueUnknown(), diags
	}

	srcSubnetVal, ok := srcSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_subnet expected to be basetypes.StringValue, was: %T`, srcSubnetAttribute))
	}

	if diags.HasError() {
		return NewOthersValueUnknown(), diags
	}

	return OthersValue{
		Dscp:       dscpVal,
		DstSubnet:  dstSubnetVal,
		PortRanges: portRangesVal,
		Protocol:   protocolVal,
		SrcSubnet:  srcSubnetVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewOthersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OthersValue {
	object, diags := NewOthersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOthersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OthersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOthersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOthersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOthersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOthersValueMust(OthersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OthersType) ValueType(ctx context.Context) attr.Value {
	return OthersValue{}
}

var _ basetypes.ObjectValuable = OthersValue{}

type OthersValue struct {
	Dscp       basetypes.Int64Value  `tfsdk:"dscp"`
	DstSubnet  basetypes.StringValue `tfsdk:"dst_subnet"`
	PortRanges basetypes.StringValue `tfsdk:"port_ranges"`
	Protocol   basetypes.StringValue `tfsdk:"protocol"`
	SrcSubnet  basetypes.StringValue `tfsdk:"src_subnet"`
	state      attr.ValueState
}

func (v OthersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["dscp"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dst_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_ranges"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["src_subnet"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Dscp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dscp"] = val

		val, err = v.DstSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dst_subnet"] = val

		val, err = v.PortRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_ranges"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.SrcSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["src_subnet"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OthersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OthersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OthersValue) String() string {
	return "OthersValue"
}

func (v OthersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"dscp":        basetypes.Int64Type{},
		"dst_subnet":  basetypes.StringType{},
		"port_ranges": basetypes.StringType{},
		"protocol":    basetypes.StringType{},
		"src_subnet":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dscp":        v.Dscp,
			"dst_subnet":  v.DstSubnet,
			"port_ranges": v.PortRanges,
			"protocol":    v.Protocol,
			"src_subnet":  v.SrcSubnet,
		})

	return objVal, diags
}

func (v OthersValue) Equal(o attr.Value) bool {
	other, ok := o.(OthersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dscp.Equal(other.Dscp) {
		return false
	}

	if !v.DstSubnet.Equal(other.DstSubnet) {
		return false
	}

	if !v.PortRanges.Equal(other.PortRanges) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.SrcSubnet.Equal(other.SrcSubnet) {
		return false
	}

	return true
}

func (v OthersValue) Type(ctx context.Context) attr.Type {
	return OthersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OthersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dscp":        basetypes.Int64Type{},
		"dst_subnet":  basetypes.StringType{},
		"port_ranges": basetypes.StringType{},
		"protocol":    basetypes.StringType{},
		"src_subnet":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuthType{}

type AuthType struct {
	basetypes.ObjectType
}

func (t AuthType) Equal(o attr.Type) bool {
	other, ok := o.(AuthType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthType) String() string {
	return "AuthType"
}

func (t AuthType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	anticlogThresholdAttribute, ok := attributes["anticlog_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anticlog_threshold is missing from object`)

		return nil, diags
	}

	anticlogThresholdVal, ok := anticlogThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anticlog_threshold expected to be basetypes.Int64Value, was: %T`, anticlogThresholdAttribute))
	}

	eapReauthAttribute, ok := attributes["eap_reauth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eap_reauth is missing from object`)

		return nil, diags
	}

	eapReauthVal, ok := eapReauthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eap_reauth expected to be basetypes.BoolValue, was: %T`, eapReauthAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return nil, diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	keyIdxAttribute, ok := attributes["key_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_idx is missing from object`)

		return nil, diags
	}

	keyIdxVal, ok := keyIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_idx expected to be basetypes.Int64Value, was: %T`, keyIdxAttribute))
	}

	keysAttribute, ok := attributes["keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keys is missing from object`)

		return nil, diags
	}

	keysVal, ok := keysAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keys expected to be basetypes.ListValue, was: %T`, keysAttribute))
	}

	multiPskOnlyAttribute, ok := attributes["multi_psk_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multi_psk_only is missing from object`)

		return nil, diags
	}

	multiPskOnlyVal, ok := multiPskOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multi_psk_only expected to be basetypes.BoolValue, was: %T`, multiPskOnlyAttribute))
	}

	oweAttribute, ok := attributes["owe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`owe is missing from object`)

		return nil, diags
	}

	oweVal, ok := oweAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`owe expected to be basetypes.StringValue, was: %T`, oweAttribute))
	}

	pairwiseAttribute, ok := attributes["pairwise"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pairwise is missing from object`)

		return nil, diags
	}

	pairwiseVal, ok := pairwiseAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pairwise expected to be basetypes.ListValue, was: %T`, pairwiseAttribute))
	}

	privateWlanAttribute, ok := attributes["private_wlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_wlan is missing from object`)

		return nil, diags
	}

	privateWlanVal, ok := privateWlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_wlan expected to be basetypes.BoolValue, was: %T`, privateWlanAttribute))
	}

	pskAttribute, ok := attributes["psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psk is missing from object`)

		return nil, diags
	}

	pskVal, ok := pskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psk expected to be basetypes.StringValue, was: %T`, pskAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	wepAsSecondaryAuthAttribute, ok := attributes["wep_as_secondary_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wep_as_secondary_auth is missing from object`)

		return nil, diags
	}

	wepAsSecondaryAuthVal, ok := wepAsSecondaryAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wep_as_secondary_auth expected to be basetypes.BoolValue, was: %T`, wepAsSecondaryAuthAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthValue{
		AnticlogThreshold:  anticlogThresholdVal,
		EapReauth:          eapReauthVal,
		EnableMacAuth:      enableMacAuthVal,
		KeyIdx:             keyIdxVal,
		Keys:               keysVal,
		MultiPskOnly:       multiPskOnlyVal,
		Owe:                oweVal,
		Pairwise:           pairwiseVal,
		PrivateWlan:        privateWlanVal,
		Psk:                pskVal,
		AuthType:           typeVal,
		WepAsSecondaryAuth: wepAsSecondaryAuthVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewAuthValueNull() AuthValue {
	return AuthValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthValueUnknown() AuthValue {
	return AuthValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthValue Attribute Value",
				"While creating a AuthValue value, a missing attribute value was detected. "+
					"A AuthValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthValue Attribute Type",
				"While creating a AuthValue value, an invalid attribute value was detected. "+
					"A AuthValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthValue Attribute Value",
				"While creating a AuthValue value, an extra attribute value was detected. "+
					"A AuthValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthValueUnknown(), diags
	}

	anticlogThresholdAttribute, ok := attributes["anticlog_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anticlog_threshold is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	anticlogThresholdVal, ok := anticlogThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anticlog_threshold expected to be basetypes.Int64Value, was: %T`, anticlogThresholdAttribute))
	}

	eapReauthAttribute, ok := attributes["eap_reauth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eap_reauth is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	eapReauthVal, ok := eapReauthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eap_reauth expected to be basetypes.BoolValue, was: %T`, eapReauthAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	keyIdxAttribute, ok := attributes["key_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_idx is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	keyIdxVal, ok := keyIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_idx expected to be basetypes.Int64Value, was: %T`, keyIdxAttribute))
	}

	keysAttribute, ok := attributes["keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keys is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	keysVal, ok := keysAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keys expected to be basetypes.ListValue, was: %T`, keysAttribute))
	}

	multiPskOnlyAttribute, ok := attributes["multi_psk_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multi_psk_only is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	multiPskOnlyVal, ok := multiPskOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multi_psk_only expected to be basetypes.BoolValue, was: %T`, multiPskOnlyAttribute))
	}

	oweAttribute, ok := attributes["owe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`owe is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	oweVal, ok := oweAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`owe expected to be basetypes.StringValue, was: %T`, oweAttribute))
	}

	pairwiseAttribute, ok := attributes["pairwise"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pairwise is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	pairwiseVal, ok := pairwiseAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pairwise expected to be basetypes.ListValue, was: %T`, pairwiseAttribute))
	}

	privateWlanAttribute, ok := attributes["private_wlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_wlan is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	privateWlanVal, ok := privateWlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_wlan expected to be basetypes.BoolValue, was: %T`, privateWlanAttribute))
	}

	pskAttribute, ok := attributes["psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psk is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	pskVal, ok := pskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psk expected to be basetypes.StringValue, was: %T`, pskAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	wepAsSecondaryAuthAttribute, ok := attributes["wep_as_secondary_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wep_as_secondary_auth is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	wepAsSecondaryAuthVal, ok := wepAsSecondaryAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wep_as_secondary_auth expected to be basetypes.BoolValue, was: %T`, wepAsSecondaryAuthAttribute))
	}

	if diags.HasError() {
		return NewAuthValueUnknown(), diags
	}

	return AuthValue{
		AnticlogThreshold:  anticlogThresholdVal,
		EapReauth:          eapReauthVal,
		EnableMacAuth:      enableMacAuthVal,
		KeyIdx:             keyIdxVal,
		Keys:               keysVal,
		MultiPskOnly:       multiPskOnlyVal,
		Owe:                oweVal,
		Pairwise:           pairwiseVal,
		PrivateWlan:        privateWlanVal,
		Psk:                pskVal,
		AuthType:           typeVal,
		WepAsSecondaryAuth: wepAsSecondaryAuthVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewAuthValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthValue {
	object, diags := NewAuthValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthValueMust(AuthValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthType) ValueType(ctx context.Context) attr.Value {
	return AuthValue{}
}

var _ basetypes.ObjectValuable = AuthValue{}

type AuthValue struct {
	AnticlogThreshold  basetypes.Int64Value  `tfsdk:"anticlog_threshold"`
	EapReauth          basetypes.BoolValue   `tfsdk:"eap_reauth"`
	EnableMacAuth      basetypes.BoolValue   `tfsdk:"enable_mac_auth"`
	KeyIdx             basetypes.Int64Value  `tfsdk:"key_idx"`
	Keys               basetypes.ListValue   `tfsdk:"keys"`
	MultiPskOnly       basetypes.BoolValue   `tfsdk:"multi_psk_only"`
	Owe                basetypes.StringValue `tfsdk:"owe"`
	Pairwise           basetypes.ListValue   `tfsdk:"pairwise"`
	PrivateWlan        basetypes.BoolValue   `tfsdk:"private_wlan"`
	Psk                basetypes.StringValue `tfsdk:"psk"`
	AuthType           basetypes.StringValue `tfsdk:"type"`
	WepAsSecondaryAuth basetypes.BoolValue   `tfsdk:"wep_as_secondary_auth"`
	state              attr.ValueState
}

func (v AuthValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["anticlog_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eap_reauth"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_mac_auth"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["key_idx"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keys"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["multi_psk_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["owe"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pairwise"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["private_wlan"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["psk"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wep_as_secondary_auth"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AnticlogThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["anticlog_threshold"] = val

		val, err = v.EapReauth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eap_reauth"] = val

		val, err = v.EnableMacAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_mac_auth"] = val

		val, err = v.KeyIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key_idx"] = val

		val, err = v.Keys.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keys"] = val

		val, err = v.MultiPskOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multi_psk_only"] = val

		val, err = v.Owe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["owe"] = val

		val, err = v.Pairwise.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pairwise"] = val

		val, err = v.PrivateWlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_wlan"] = val

		val, err = v.Psk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["psk"] = val

		val, err = v.AuthType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.WepAsSecondaryAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wep_as_secondary_auth"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthValue) String() string {
	return "AuthValue"
}

func (v AuthValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	keysVal, d := types.ListValue(types.StringType, v.Keys.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"anticlog_threshold": basetypes.Int64Type{},
			"eap_reauth":         basetypes.BoolType{},
			"enable_mac_auth":    basetypes.BoolType{},
			"key_idx":            basetypes.Int64Type{},
			"keys": basetypes.ListType{
				ElemType: types.StringType,
			},
			"multi_psk_only": basetypes.BoolType{},
			"owe":            basetypes.StringType{},
			"pairwise": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_wlan":          basetypes.BoolType{},
			"psk":                   basetypes.StringType{},
			"type":                  basetypes.StringType{},
			"wep_as_secondary_auth": basetypes.BoolType{},
		}), diags
	}

	pairwiseVal, d := types.ListValue(types.StringType, v.Pairwise.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"anticlog_threshold": basetypes.Int64Type{},
			"eap_reauth":         basetypes.BoolType{},
			"enable_mac_auth":    basetypes.BoolType{},
			"key_idx":            basetypes.Int64Type{},
			"keys": basetypes.ListType{
				ElemType: types.StringType,
			},
			"multi_psk_only": basetypes.BoolType{},
			"owe":            basetypes.StringType{},
			"pairwise": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_wlan":          basetypes.BoolType{},
			"psk":                   basetypes.StringType{},
			"type":                  basetypes.StringType{},
			"wep_as_secondary_auth": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"anticlog_threshold": basetypes.Int64Type{},
		"eap_reauth":         basetypes.BoolType{},
		"enable_mac_auth":    basetypes.BoolType{},
		"key_idx":            basetypes.Int64Type{},
		"keys": basetypes.ListType{
			ElemType: types.StringType,
		},
		"multi_psk_only": basetypes.BoolType{},
		"owe":            basetypes.StringType{},
		"pairwise": basetypes.ListType{
			ElemType: types.StringType,
		},
		"private_wlan":          basetypes.BoolType{},
		"psk":                   basetypes.StringType{},
		"type":                  basetypes.StringType{},
		"wep_as_secondary_auth": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"anticlog_threshold":    v.AnticlogThreshold,
			"eap_reauth":            v.EapReauth,
			"enable_mac_auth":       v.EnableMacAuth,
			"key_idx":               v.KeyIdx,
			"keys":                  keysVal,
			"multi_psk_only":        v.MultiPskOnly,
			"owe":                   v.Owe,
			"pairwise":              pairwiseVal,
			"private_wlan":          v.PrivateWlan,
			"psk":                   v.Psk,
			"type":                  v.AuthType,
			"wep_as_secondary_auth": v.WepAsSecondaryAuth,
		})

	return objVal, diags
}

func (v AuthValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AnticlogThreshold.Equal(other.AnticlogThreshold) {
		return false
	}

	if !v.EapReauth.Equal(other.EapReauth) {
		return false
	}

	if !v.EnableMacAuth.Equal(other.EnableMacAuth) {
		return false
	}

	if !v.KeyIdx.Equal(other.KeyIdx) {
		return false
	}

	if !v.Keys.Equal(other.Keys) {
		return false
	}

	if !v.MultiPskOnly.Equal(other.MultiPskOnly) {
		return false
	}

	if !v.Owe.Equal(other.Owe) {
		return false
	}

	if !v.Pairwise.Equal(other.Pairwise) {
		return false
	}

	if !v.PrivateWlan.Equal(other.PrivateWlan) {
		return false
	}

	if !v.Psk.Equal(other.Psk) {
		return false
	}

	if !v.AuthType.Equal(other.AuthType) {
		return false
	}

	if !v.WepAsSecondaryAuth.Equal(other.WepAsSecondaryAuth) {
		return false
	}

	return true
}

func (v AuthValue) Type(ctx context.Context) attr.Type {
	return AuthType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"anticlog_threshold": basetypes.Int64Type{},
		"eap_reauth":         basetypes.BoolType{},
		"enable_mac_auth":    basetypes.BoolType{},
		"key_idx":            basetypes.Int64Type{},
		"keys": basetypes.ListType{
			ElemType: types.StringType,
		},
		"multi_psk_only": basetypes.BoolType{},
		"owe":            basetypes.StringType{},
		"pairwise": basetypes.ListType{
			ElemType: types.StringType,
		},
		"private_wlan":          basetypes.BoolType{},
		"psk":                   basetypes.StringType{},
		"type":                  basetypes.StringType{},
		"wep_as_secondary_auth": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = AuthServersType{}

type AuthServersType struct {
	basetypes.ObjectType
}

func (t AuthServersType) Equal(o attr.Type) bool {
	other, ok := o.(AuthServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthServersType) String() string {
	return "AuthServersType"
}

func (t AuthServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueNull() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthServersValueUnknown() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, a missing attribute value was detected. "+
					"A AuthServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthServersValue Attribute Type",
				"While creating a AuthServersValue value, an invalid attribute value was detected. "+
					"A AuthServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, an extra attribute value was detected. "+
					"A AuthServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	return AuthServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthServersValue {
	object, diags := NewAuthServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthServersValueMust(AuthServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthServersType) ValueType(ctx context.Context) attr.Value {
	return AuthServersValue{}
}

var _ basetypes.ObjectValuable = AuthServersValue{}

type AuthServersValue struct {
	Host           basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat  basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek     basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack    basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port           basetypes.Int64Value  `tfsdk:"port"`
	Secret         basetypes.StringValue `tfsdk:"secret"`
	state          attr.ValueState
}

func (v AuthServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthServersValue) String() string {
	return "AuthServersValue"
}

func (v AuthServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":            v.Host,
			"keywrap_enabled": v.KeywrapEnabled,
			"keywrap_format":  v.KeywrapFormat,
			"keywrap_kek":     v.KeywrapKek,
			"keywrap_mack":    v.KeywrapMack,
			"port":            v.Port,
			"secret":          v.Secret,
		})

	return objVal, diags
}

func (v AuthServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AuthServersValue) Type(ctx context.Context) attr.Type {
	return AuthServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BonjourType{}

type BonjourType struct {
	basetypes.ObjectType
}

func (t BonjourType) Equal(o attr.Type) bool {
	other, ok := o.(BonjourType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BonjourType) String() string {
	return "BonjourType"
}

func (t BonjourType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return nil, diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return nil, diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.MapValue, was: %T`, servicesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BonjourValue{
		AdditionalVlanIds: additionalVlanIdsVal,
		Enabled:           enabledVal,
		Services:          servicesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBonjourValueNull() BonjourValue {
	return BonjourValue{
		state: attr.ValueStateNull,
	}
}

func NewBonjourValueUnknown() BonjourValue {
	return BonjourValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBonjourValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BonjourValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BonjourValue Attribute Value",
				"While creating a BonjourValue value, a missing attribute value was detected. "+
					"A BonjourValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BonjourValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BonjourValue Attribute Type",
				"While creating a BonjourValue value, an invalid attribute value was detected. "+
					"A BonjourValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BonjourValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BonjourValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BonjourValue Attribute Value",
				"While creating a BonjourValue value, an extra attribute value was detected. "+
					"A BonjourValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BonjourValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBonjourValueUnknown(), diags
	}

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return NewBonjourValueUnknown(), diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBonjourValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return NewBonjourValueUnknown(), diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.MapValue, was: %T`, servicesAttribute))
	}

	if diags.HasError() {
		return NewBonjourValueUnknown(), diags
	}

	return BonjourValue{
		AdditionalVlanIds: additionalVlanIdsVal,
		Enabled:           enabledVal,
		Services:          servicesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBonjourValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BonjourValue {
	object, diags := NewBonjourValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBonjourValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BonjourType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBonjourValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBonjourValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBonjourValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBonjourValueMust(BonjourValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BonjourType) ValueType(ctx context.Context) attr.Value {
	return BonjourValue{}
}

var _ basetypes.ObjectValuable = BonjourValue{}

type BonjourValue struct {
	AdditionalVlanIds basetypes.ListValue `tfsdk:"additional_vlan_ids"`
	Enabled           basetypes.BoolValue `tfsdk:"enabled"`
	Services          basetypes.MapValue  `tfsdk:"services"`
	state             attr.ValueState
}

func (v BonjourValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["additional_vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["services"] = basetypes.MapType{
		ElemType: ServicesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AdditionalVlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_vlan_ids"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Services.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["services"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BonjourValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BonjourValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BonjourValue) String() string {
	return "BonjourValue"
}

func (v BonjourValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	services := types.MapValueMust(
		ServicesType{
			basetypes.ObjectType{
				AttrTypes: ServicesValue{}.AttributeTypes(ctx),
			},
		},
		v.Services.Elements(),
	)

	if v.Services.IsNull() {
		services = types.MapNull(
			ServicesType{
				basetypes.ObjectType{
					AttrTypes: ServicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Services.IsUnknown() {
		services = types.MapUnknown(
			ServicesType{
				basetypes.ObjectType{
					AttrTypes: ServicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	additionalVlanIdsVal, d := types.ListValue(types.Int64Type, v.AdditionalVlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enabled": basetypes.BoolType{},
			"services": basetypes.MapType{
				ElemType: ServicesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enabled": basetypes.BoolType{},
		"services": basetypes.MapType{
			ElemType: ServicesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"additional_vlan_ids": additionalVlanIdsVal,
			"enabled":             v.Enabled,
			"services":            services,
		})

	return objVal, diags
}

func (v BonjourValue) Equal(o attr.Value) bool {
	other, ok := o.(BonjourValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalVlanIds.Equal(other.AdditionalVlanIds) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Services.Equal(other.Services) {
		return false
	}

	return true
}

func (v BonjourValue) Type(ctx context.Context) attr.Type {
	return BonjourType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BonjourValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enabled": basetypes.BoolType{},
		"services": basetypes.MapType{
			ElemType: ServicesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ServicesType{}

type ServicesType struct {
	basetypes.ObjectType
}

func (t ServicesType) Equal(o attr.Type) bool {
	other, ok := o.(ServicesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServicesType) String() string {
	return "ServicesType"
}

func (t ServicesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disableLocalAttribute, ok := attributes["disable_local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_local is missing from object`)

		return nil, diags
	}

	disableLocalVal, ok := disableLocalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_local expected to be basetypes.BoolValue, was: %T`, disableLocalAttribute))
	}

	radiusGroupsAttribute, ok := attributes["radius_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_groups is missing from object`)

		return nil, diags
	}

	radiusGroupsVal, ok := radiusGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_groups expected to be basetypes.ListValue, was: %T`, radiusGroupsAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return nil, diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServicesValue{
		DisableLocal: disableLocalVal,
		RadiusGroups: radiusGroupsVal,
		Scope:        scopeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewServicesValueNull() ServicesValue {
	return ServicesValue{
		state: attr.ValueStateNull,
	}
}

func NewServicesValueUnknown() ServicesValue {
	return ServicesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServicesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServicesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServicesValue Attribute Value",
				"While creating a ServicesValue value, a missing attribute value was detected. "+
					"A ServicesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServicesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServicesValue Attribute Type",
				"While creating a ServicesValue value, an invalid attribute value was detected. "+
					"A ServicesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServicesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServicesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServicesValue Attribute Value",
				"While creating a ServicesValue value, an extra attribute value was detected. "+
					"A ServicesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServicesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServicesValueUnknown(), diags
	}

	disableLocalAttribute, ok := attributes["disable_local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_local is missing from object`)

		return NewServicesValueUnknown(), diags
	}

	disableLocalVal, ok := disableLocalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_local expected to be basetypes.BoolValue, was: %T`, disableLocalAttribute))
	}

	radiusGroupsAttribute, ok := attributes["radius_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_groups is missing from object`)

		return NewServicesValueUnknown(), diags
	}

	radiusGroupsVal, ok := radiusGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_groups expected to be basetypes.ListValue, was: %T`, radiusGroupsAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return NewServicesValueUnknown(), diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	if diags.HasError() {
		return NewServicesValueUnknown(), diags
	}

	return ServicesValue{
		DisableLocal: disableLocalVal,
		RadiusGroups: radiusGroupsVal,
		Scope:        scopeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewServicesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServicesValue {
	object, diags := NewServicesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServicesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServicesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServicesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServicesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServicesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServicesValueMust(ServicesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServicesType) ValueType(ctx context.Context) attr.Value {
	return ServicesValue{}
}

var _ basetypes.ObjectValuable = ServicesValue{}

type ServicesValue struct {
	DisableLocal basetypes.BoolValue   `tfsdk:"disable_local"`
	RadiusGroups basetypes.ListValue   `tfsdk:"radius_groups"`
	Scope        basetypes.StringValue `tfsdk:"scope"`
	state        attr.ValueState
}

func (v ServicesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["disable_local"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["radius_groups"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["scope"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DisableLocal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_local"] = val

		val, err = v.RadiusGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["radius_groups"] = val

		val, err = v.Scope.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServicesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServicesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServicesValue) String() string {
	return "ServicesValue"
}

func (v ServicesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	radiusGroupsVal, d := types.ListValue(types.StringType, v.RadiusGroups.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"disable_local": basetypes.BoolType{},
			"radius_groups": basetypes.ListType{
				ElemType: types.StringType,
			},
			"scope": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"disable_local": basetypes.BoolType{},
		"radius_groups": basetypes.ListType{
			ElemType: types.StringType,
		},
		"scope": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disable_local": v.DisableLocal,
			"radius_groups": radiusGroupsVal,
			"scope":         v.Scope,
		})

	return objVal, diags
}

func (v ServicesValue) Equal(o attr.Value) bool {
	other, ok := o.(ServicesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisableLocal.Equal(other.DisableLocal) {
		return false
	}

	if !v.RadiusGroups.Equal(other.RadiusGroups) {
		return false
	}

	if !v.Scope.Equal(other.Scope) {
		return false
	}

	return true
}

func (v ServicesValue) Type(ctx context.Context) attr.Type {
	return ServicesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServicesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disable_local": basetypes.BoolType{},
		"radius_groups": basetypes.ListType{
			ElemType: types.StringType,
		},
		"scope": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CiscoCwaType{}

type CiscoCwaType struct {
	basetypes.ObjectType
}

func (t CiscoCwaType) Equal(o attr.Type) bool {
	other, ok := o.(CiscoCwaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CiscoCwaType) String() string {
	return "CiscoCwaType"
}

func (t CiscoCwaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowedHostnamesAttribute, ok := attributes["allowed_hostnames"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_hostnames is missing from object`)

		return nil, diags
	}

	allowedHostnamesVal, ok := allowedHostnamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_hostnames expected to be basetypes.ListValue, was: %T`, allowedHostnamesAttribute))
	}

	allowedSubnetsAttribute, ok := attributes["allowed_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_subnets is missing from object`)

		return nil, diags
	}

	allowedSubnetsVal, ok := allowedSubnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_subnets expected to be basetypes.ListValue, was: %T`, allowedSubnetsAttribute))
	}

	blockedSubnetsAttribute, ok := attributes["blocked_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blocked_subnets is missing from object`)

		return nil, diags
	}

	blockedSubnetsVal, ok := blockedSubnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blocked_subnets expected to be basetypes.ListValue, was: %T`, blockedSubnetsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CiscoCwaValue{
		AllowedHostnames: allowedHostnamesVal,
		AllowedSubnets:   allowedSubnetsVal,
		BlockedSubnets:   blockedSubnetsVal,
		Enabled:          enabledVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCiscoCwaValueNull() CiscoCwaValue {
	return CiscoCwaValue{
		state: attr.ValueStateNull,
	}
}

func NewCiscoCwaValueUnknown() CiscoCwaValue {
	return CiscoCwaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCiscoCwaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CiscoCwaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CiscoCwaValue Attribute Value",
				"While creating a CiscoCwaValue value, a missing attribute value was detected. "+
					"A CiscoCwaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CiscoCwaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CiscoCwaValue Attribute Type",
				"While creating a CiscoCwaValue value, an invalid attribute value was detected. "+
					"A CiscoCwaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CiscoCwaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CiscoCwaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CiscoCwaValue Attribute Value",
				"While creating a CiscoCwaValue value, an extra attribute value was detected. "+
					"A CiscoCwaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CiscoCwaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCiscoCwaValueUnknown(), diags
	}

	allowedHostnamesAttribute, ok := attributes["allowed_hostnames"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_hostnames is missing from object`)

		return NewCiscoCwaValueUnknown(), diags
	}

	allowedHostnamesVal, ok := allowedHostnamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_hostnames expected to be basetypes.ListValue, was: %T`, allowedHostnamesAttribute))
	}

	allowedSubnetsAttribute, ok := attributes["allowed_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_subnets is missing from object`)

		return NewCiscoCwaValueUnknown(), diags
	}

	allowedSubnetsVal, ok := allowedSubnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_subnets expected to be basetypes.ListValue, was: %T`, allowedSubnetsAttribute))
	}

	blockedSubnetsAttribute, ok := attributes["blocked_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blocked_subnets is missing from object`)

		return NewCiscoCwaValueUnknown(), diags
	}

	blockedSubnetsVal, ok := blockedSubnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blocked_subnets expected to be basetypes.ListValue, was: %T`, blockedSubnetsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewCiscoCwaValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewCiscoCwaValueUnknown(), diags
	}

	return CiscoCwaValue{
		AllowedHostnames: allowedHostnamesVal,
		AllowedSubnets:   allowedSubnetsVal,
		BlockedSubnets:   blockedSubnetsVal,
		Enabled:          enabledVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCiscoCwaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CiscoCwaValue {
	object, diags := NewCiscoCwaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCiscoCwaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CiscoCwaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCiscoCwaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCiscoCwaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCiscoCwaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCiscoCwaValueMust(CiscoCwaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CiscoCwaType) ValueType(ctx context.Context) attr.Value {
	return CiscoCwaValue{}
}

var _ basetypes.ObjectValuable = CiscoCwaValue{}

type CiscoCwaValue struct {
	AllowedHostnames basetypes.ListValue `tfsdk:"allowed_hostnames"`
	AllowedSubnets   basetypes.ListValue `tfsdk:"allowed_subnets"`
	BlockedSubnets   basetypes.ListValue `tfsdk:"blocked_subnets"`
	Enabled          basetypes.BoolValue `tfsdk:"enabled"`
	state            attr.ValueState
}

func (v CiscoCwaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["allowed_hostnames"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["allowed_subnets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["blocked_subnets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AllowedHostnames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_hostnames"] = val

		val, err = v.AllowedSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_subnets"] = val

		val, err = v.BlockedSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blocked_subnets"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CiscoCwaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CiscoCwaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CiscoCwaValue) String() string {
	return "CiscoCwaValue"
}

func (v CiscoCwaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	allowedHostnamesVal, d := types.ListValue(types.StringType, v.AllowedHostnames.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"blocked_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
		}), diags
	}

	allowedSubnetsVal, d := types.ListValue(types.StringType, v.AllowedSubnets.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"blocked_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
		}), diags
	}

	blockedSubnetsVal, d := types.ListValue(types.StringType, v.BlockedSubnets.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"blocked_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allowed_hostnames": basetypes.ListType{
			ElemType: types.StringType,
		},
		"allowed_subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"blocked_subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allowed_hostnames": allowedHostnamesVal,
			"allowed_subnets":   allowedSubnetsVal,
			"blocked_subnets":   blockedSubnetsVal,
			"enabled":           v.Enabled,
		})

	return objVal, diags
}

func (v CiscoCwaValue) Equal(o attr.Value) bool {
	other, ok := o.(CiscoCwaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowedHostnames.Equal(other.AllowedHostnames) {
		return false
	}

	if !v.AllowedSubnets.Equal(other.AllowedSubnets) {
		return false
	}

	if !v.BlockedSubnets.Equal(other.BlockedSubnets) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v CiscoCwaValue) Type(ctx context.Context) attr.Type {
	return CiscoCwaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CiscoCwaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allowed_hostnames": basetypes.ListType{
			ElemType: types.StringType,
		},
		"allowed_subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"blocked_subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = CoaServersType{}

type CoaServersType struct {
	basetypes.ObjectType
}

func (t CoaServersType) Equal(o attr.Type) bool {
	other, ok := o.(CoaServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CoaServersType) String() string {
	return "CoaServersType"
}

func (t CoaServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disableEventTimestampCheckAttribute, ok := attributes["disable_event_timestamp_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_event_timestamp_check is missing from object`)

		return nil, diags
	}

	disableEventTimestampCheckVal, ok := disableEventTimestampCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_event_timestamp_check expected to be basetypes.BoolValue, was: %T`, disableEventTimestampCheckAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CoaServersValue{
		DisableEventTimestampCheck: disableEventTimestampCheckVal,
		Enabled:                    enabledVal,
		Ip:                         ipVal,
		Port:                       portVal,
		Secret:                     secretVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewCoaServersValueNull() CoaServersValue {
	return CoaServersValue{
		state: attr.ValueStateNull,
	}
}

func NewCoaServersValueUnknown() CoaServersValue {
	return CoaServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCoaServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CoaServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CoaServersValue Attribute Value",
				"While creating a CoaServersValue value, a missing attribute value was detected. "+
					"A CoaServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CoaServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CoaServersValue Attribute Type",
				"While creating a CoaServersValue value, an invalid attribute value was detected. "+
					"A CoaServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CoaServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CoaServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CoaServersValue Attribute Value",
				"While creating a CoaServersValue value, an extra attribute value was detected. "+
					"A CoaServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CoaServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCoaServersValueUnknown(), diags
	}

	disableEventTimestampCheckAttribute, ok := attributes["disable_event_timestamp_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_event_timestamp_check is missing from object`)

		return NewCoaServersValueUnknown(), diags
	}

	disableEventTimestampCheckVal, ok := disableEventTimestampCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_event_timestamp_check expected to be basetypes.BoolValue, was: %T`, disableEventTimestampCheckAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewCoaServersValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewCoaServersValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewCoaServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewCoaServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewCoaServersValueUnknown(), diags
	}

	return CoaServersValue{
		DisableEventTimestampCheck: disableEventTimestampCheckVal,
		Enabled:                    enabledVal,
		Ip:                         ipVal,
		Port:                       portVal,
		Secret:                     secretVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewCoaServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CoaServersValue {
	object, diags := NewCoaServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCoaServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CoaServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCoaServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCoaServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCoaServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCoaServersValueMust(CoaServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CoaServersType) ValueType(ctx context.Context) attr.Value {
	return CoaServersValue{}
}

var _ basetypes.ObjectValuable = CoaServersValue{}

type CoaServersValue struct {
	DisableEventTimestampCheck basetypes.BoolValue   `tfsdk:"disable_event_timestamp_check"`
	Enabled                    basetypes.BoolValue   `tfsdk:"enabled"`
	Ip                         basetypes.StringValue `tfsdk:"ip"`
	Port                       basetypes.Int64Value  `tfsdk:"port"`
	Secret                     basetypes.StringValue `tfsdk:"secret"`
	state                      attr.ValueState
}

func (v CoaServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["disable_event_timestamp_check"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DisableEventTimestampCheck.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_event_timestamp_check"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CoaServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CoaServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CoaServersValue) String() string {
	return "CoaServersValue"
}

func (v CoaServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"disable_event_timestamp_check": basetypes.BoolType{},
		"enabled":                       basetypes.BoolType{},
		"ip":                            basetypes.StringType{},
		"port":                          basetypes.Int64Type{},
		"secret":                        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disable_event_timestamp_check": v.DisableEventTimestampCheck,
			"enabled":                       v.Enabled,
			"ip":                            v.Ip,
			"port":                          v.Port,
			"secret":                        v.Secret,
		})

	return objVal, diags
}

func (v CoaServersValue) Equal(o attr.Value) bool {
	other, ok := o.(CoaServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisableEventTimestampCheck.Equal(other.DisableEventTimestampCheck) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v CoaServersValue) Type(ctx context.Context) attr.Type {
	return CoaServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CoaServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disable_event_timestamp_check": basetypes.BoolType{},
		"enabled":                       basetypes.BoolType{},
		"ip":                            basetypes.StringType{},
		"port":                          basetypes.Int64Type{},
		"secret":                        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DnsServerRewriteType{}

type DnsServerRewriteType struct {
	basetypes.ObjectType
}

func (t DnsServerRewriteType) Equal(o attr.Type) bool {
	other, ok := o.(DnsServerRewriteType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DnsServerRewriteType) String() string {
	return "DnsServerRewriteType"
}

func (t DnsServerRewriteType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	radiusGroupsAttribute, ok := attributes["radius_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_groups is missing from object`)

		return nil, diags
	}

	radiusGroupsVal, ok := radiusGroupsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_groups expected to be basetypes.MapValue, was: %T`, radiusGroupsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DnsServerRewriteValue{
		Enabled:      enabledVal,
		RadiusGroups: radiusGroupsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDnsServerRewriteValueNull() DnsServerRewriteValue {
	return DnsServerRewriteValue{
		state: attr.ValueStateNull,
	}
}

func NewDnsServerRewriteValueUnknown() DnsServerRewriteValue {
	return DnsServerRewriteValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDnsServerRewriteValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DnsServerRewriteValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DnsServerRewriteValue Attribute Value",
				"While creating a DnsServerRewriteValue value, a missing attribute value was detected. "+
					"A DnsServerRewriteValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DnsServerRewriteValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DnsServerRewriteValue Attribute Type",
				"While creating a DnsServerRewriteValue value, an invalid attribute value was detected. "+
					"A DnsServerRewriteValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DnsServerRewriteValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DnsServerRewriteValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DnsServerRewriteValue Attribute Value",
				"While creating a DnsServerRewriteValue value, an extra attribute value was detected. "+
					"A DnsServerRewriteValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DnsServerRewriteValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDnsServerRewriteValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDnsServerRewriteValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	radiusGroupsAttribute, ok := attributes["radius_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_groups is missing from object`)

		return NewDnsServerRewriteValueUnknown(), diags
	}

	radiusGroupsVal, ok := radiusGroupsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_groups expected to be basetypes.MapValue, was: %T`, radiusGroupsAttribute))
	}

	if diags.HasError() {
		return NewDnsServerRewriteValueUnknown(), diags
	}

	return DnsServerRewriteValue{
		Enabled:      enabledVal,
		RadiusGroups: radiusGroupsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDnsServerRewriteValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DnsServerRewriteValue {
	object, diags := NewDnsServerRewriteValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDnsServerRewriteValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DnsServerRewriteType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDnsServerRewriteValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDnsServerRewriteValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDnsServerRewriteValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDnsServerRewriteValueMust(DnsServerRewriteValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DnsServerRewriteType) ValueType(ctx context.Context) attr.Value {
	return DnsServerRewriteValue{}
}

var _ basetypes.ObjectValuable = DnsServerRewriteValue{}

type DnsServerRewriteValue struct {
	Enabled      basetypes.BoolValue `tfsdk:"enabled"`
	RadiusGroups basetypes.MapValue  `tfsdk:"radius_groups"`
	state        attr.ValueState
}

func (v DnsServerRewriteValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["radius_groups"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.RadiusGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["radius_groups"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DnsServerRewriteValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DnsServerRewriteValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DnsServerRewriteValue) String() string {
	return "DnsServerRewriteValue"
}

func (v DnsServerRewriteValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	radiusGroupsVal, d := types.MapValue(types.StringType, v.RadiusGroups.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"radius_groups": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"radius_groups": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":       v.Enabled,
			"radius_groups": radiusGroupsVal,
		})

	return objVal, diags
}

func (v DnsServerRewriteValue) Equal(o attr.Value) bool {
	other, ok := o.(DnsServerRewriteValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.RadiusGroups.Equal(other.RadiusGroups) {
		return false
	}

	return true
}

func (v DnsServerRewriteValue) Type(ctx context.Context) attr.Type {
	return DnsServerRewriteType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DnsServerRewriteValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"radius_groups": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = DynamicPskType{}

type DynamicPskType struct {
	basetypes.ObjectType
}

func (t DynamicPskType) Equal(o attr.Type) bool {
	other, ok := o.(DynamicPskType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DynamicPskType) String() string {
	return "DynamicPskType"
}

func (t DynamicPskType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultPskAttribute, ok := attributes["default_psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_psk is missing from object`)

		return nil, diags
	}

	defaultPskVal, ok := defaultPskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_psk expected to be basetypes.StringValue, was: %T`, defaultPskAttribute))
	}

	defaultVlanIdAttribute, ok := attributes["default_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_vlan_id is missing from object`)

		return nil, diags
	}

	defaultVlanIdVal, ok := defaultVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_vlan_id expected to be basetypes.Int64Value, was: %T`, defaultVlanIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	forceLookupAttribute, ok := attributes["force_lookup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`force_lookup is missing from object`)

		return nil, diags
	}

	forceLookupVal, ok := forceLookupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`force_lookup expected to be basetypes.BoolValue, was: %T`, forceLookupAttribute))
	}

	sourceAttribute, ok := attributes["source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source is missing from object`)

		return nil, diags
	}

	sourceVal, ok := sourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source expected to be basetypes.StringValue, was: %T`, sourceAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DynamicPskValue{
		DefaultPsk:    defaultPskVal,
		DefaultVlanId: defaultVlanIdVal,
		Enabled:       enabledVal,
		ForceLookup:   forceLookupVal,
		Source:        sourceVal,
		VlanIds:       vlanIdsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDynamicPskValueNull() DynamicPskValue {
	return DynamicPskValue{
		state: attr.ValueStateNull,
	}
}

func NewDynamicPskValueUnknown() DynamicPskValue {
	return DynamicPskValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDynamicPskValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DynamicPskValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DynamicPskValue Attribute Value",
				"While creating a DynamicPskValue value, a missing attribute value was detected. "+
					"A DynamicPskValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicPskValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DynamicPskValue Attribute Type",
				"While creating a DynamicPskValue value, an invalid attribute value was detected. "+
					"A DynamicPskValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicPskValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DynamicPskValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DynamicPskValue Attribute Value",
				"While creating a DynamicPskValue value, an extra attribute value was detected. "+
					"A DynamicPskValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DynamicPskValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDynamicPskValueUnknown(), diags
	}

	defaultPskAttribute, ok := attributes["default_psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_psk is missing from object`)

		return NewDynamicPskValueUnknown(), diags
	}

	defaultPskVal, ok := defaultPskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_psk expected to be basetypes.StringValue, was: %T`, defaultPskAttribute))
	}

	defaultVlanIdAttribute, ok := attributes["default_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_vlan_id is missing from object`)

		return NewDynamicPskValueUnknown(), diags
	}

	defaultVlanIdVal, ok := defaultVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_vlan_id expected to be basetypes.Int64Value, was: %T`, defaultVlanIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDynamicPskValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	forceLookupAttribute, ok := attributes["force_lookup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`force_lookup is missing from object`)

		return NewDynamicPskValueUnknown(), diags
	}

	forceLookupVal, ok := forceLookupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`force_lookup expected to be basetypes.BoolValue, was: %T`, forceLookupAttribute))
	}

	sourceAttribute, ok := attributes["source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source is missing from object`)

		return NewDynamicPskValueUnknown(), diags
	}

	sourceVal, ok := sourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source expected to be basetypes.StringValue, was: %T`, sourceAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewDynamicPskValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewDynamicPskValueUnknown(), diags
	}

	return DynamicPskValue{
		DefaultPsk:    defaultPskVal,
		DefaultVlanId: defaultVlanIdVal,
		Enabled:       enabledVal,
		ForceLookup:   forceLookupVal,
		Source:        sourceVal,
		VlanIds:       vlanIdsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDynamicPskValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DynamicPskValue {
	object, diags := NewDynamicPskValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDynamicPskValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DynamicPskType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDynamicPskValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDynamicPskValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDynamicPskValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDynamicPskValueMust(DynamicPskValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DynamicPskType) ValueType(ctx context.Context) attr.Value {
	return DynamicPskValue{}
}

var _ basetypes.ObjectValuable = DynamicPskValue{}

type DynamicPskValue struct {
	DefaultPsk    basetypes.StringValue `tfsdk:"default_psk"`
	DefaultVlanId basetypes.Int64Value  `tfsdk:"default_vlan_id"`
	Enabled       basetypes.BoolValue   `tfsdk:"enabled"`
	ForceLookup   basetypes.BoolValue   `tfsdk:"force_lookup"`
	Source        basetypes.StringValue `tfsdk:"source"`
	VlanIds       basetypes.ListValue   `tfsdk:"vlan_ids"`
	state         attr.ValueState
}

func (v DynamicPskValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["default_psk"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["default_vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["force_lookup"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["source"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.DefaultPsk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_psk"] = val

		val, err = v.DefaultVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_vlan_id"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.ForceLookup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["force_lookup"] = val

		val, err = v.Source.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DynamicPskValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DynamicPskValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DynamicPskValue) String() string {
	return "DynamicPskValue"
}

func (v DynamicPskValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	vlanIdsVal, d := types.ListValue(types.Int64Type, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"default_psk":     basetypes.StringType{},
			"default_vlan_id": basetypes.Int64Type{},
			"enabled":         basetypes.BoolType{},
			"force_lookup":    basetypes.BoolType{},
			"source":          basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"default_psk":     basetypes.StringType{},
		"default_vlan_id": basetypes.Int64Type{},
		"enabled":         basetypes.BoolType{},
		"force_lookup":    basetypes.BoolType{},
		"source":          basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_psk":     v.DefaultPsk,
			"default_vlan_id": v.DefaultVlanId,
			"enabled":         v.Enabled,
			"force_lookup":    v.ForceLookup,
			"source":          v.Source,
			"vlan_ids":        vlanIdsVal,
		})

	return objVal, diags
}

func (v DynamicPskValue) Equal(o attr.Value) bool {
	other, ok := o.(DynamicPskValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultPsk.Equal(other.DefaultPsk) {
		return false
	}

	if !v.DefaultVlanId.Equal(other.DefaultVlanId) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.ForceLookup.Equal(other.ForceLookup) {
		return false
	}

	if !v.Source.Equal(other.Source) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v DynamicPskValue) Type(ctx context.Context) attr.Type {
	return DynamicPskType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DynamicPskValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_psk":     basetypes.StringType{},
		"default_vlan_id": basetypes.Int64Type{},
		"enabled":         basetypes.BoolType{},
		"force_lookup":    basetypes.BoolType{},
		"source":          basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}
}

var _ basetypes.ObjectTypable = DynamicVlanType{}

type DynamicVlanType struct {
	basetypes.ObjectType
}

func (t DynamicVlanType) Equal(o attr.Type) bool {
	other, ok := o.(DynamicVlanType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DynamicVlanType) String() string {
	return "DynamicVlanType"
}

func (t DynamicVlanType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultVlanIdAttribute, ok := attributes["default_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_vlan_id is missing from object`)

		return nil, diags
	}

	defaultVlanIdVal, ok := defaultVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_vlan_id expected to be basetypes.Int64Value, was: %T`, defaultVlanIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	localVlanIdsAttribute, ok := attributes["local_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_vlan_ids is missing from object`)

		return nil, diags
	}

	localVlanIdsVal, ok := localVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_vlan_ids expected to be basetypes.ListValue, was: %T`, localVlanIdsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return nil, diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.MapValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DynamicVlanValue{
		DefaultVlanId:   defaultVlanIdVal,
		Enabled:         enabledVal,
		LocalVlanIds:    localVlanIdsVal,
		DynamicVlanType: typeVal,
		Vlans:           vlansVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewDynamicVlanValueNull() DynamicVlanValue {
	return DynamicVlanValue{
		state: attr.ValueStateNull,
	}
}

func NewDynamicVlanValueUnknown() DynamicVlanValue {
	return DynamicVlanValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDynamicVlanValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DynamicVlanValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DynamicVlanValue Attribute Value",
				"While creating a DynamicVlanValue value, a missing attribute value was detected. "+
					"A DynamicVlanValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicVlanValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DynamicVlanValue Attribute Type",
				"While creating a DynamicVlanValue value, an invalid attribute value was detected. "+
					"A DynamicVlanValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicVlanValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DynamicVlanValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DynamicVlanValue Attribute Value",
				"While creating a DynamicVlanValue value, an extra attribute value was detected. "+
					"A DynamicVlanValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DynamicVlanValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDynamicVlanValueUnknown(), diags
	}

	defaultVlanIdAttribute, ok := attributes["default_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_vlan_id is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	defaultVlanIdVal, ok := defaultVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_vlan_id expected to be basetypes.Int64Value, was: %T`, defaultVlanIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	localVlanIdsAttribute, ok := attributes["local_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_vlan_ids is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	localVlanIdsVal, ok := localVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_vlan_ids expected to be basetypes.ListValue, was: %T`, localVlanIdsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.MapValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return NewDynamicVlanValueUnknown(), diags
	}

	return DynamicVlanValue{
		DefaultVlanId:   defaultVlanIdVal,
		Enabled:         enabledVal,
		LocalVlanIds:    localVlanIdsVal,
		DynamicVlanType: typeVal,
		Vlans:           vlansVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewDynamicVlanValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DynamicVlanValue {
	object, diags := NewDynamicVlanValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDynamicVlanValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DynamicVlanType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDynamicVlanValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDynamicVlanValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDynamicVlanValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDynamicVlanValueMust(DynamicVlanValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DynamicVlanType) ValueType(ctx context.Context) attr.Value {
	return DynamicVlanValue{}
}

var _ basetypes.ObjectValuable = DynamicVlanValue{}

type DynamicVlanValue struct {
	DefaultVlanId   basetypes.Int64Value  `tfsdk:"default_vlan_id"`
	Enabled         basetypes.BoolValue   `tfsdk:"enabled"`
	LocalVlanIds    basetypes.ListValue   `tfsdk:"local_vlan_ids"`
	DynamicVlanType basetypes.StringValue `tfsdk:"type"`
	Vlans           basetypes.MapValue    `tfsdk:"vlans"`
	state           attr.ValueState
}

func (v DynamicVlanValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["default_vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["local_vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlans"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DefaultVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_vlan_id"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.LocalVlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_vlan_ids"] = val

		val, err = v.DynamicVlanType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Vlans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlans"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DynamicVlanValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DynamicVlanValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DynamicVlanValue) String() string {
	return "DynamicVlanValue"
}

func (v DynamicVlanValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	localVlanIdsVal, d := types.ListValue(types.Int64Type, v.LocalVlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"default_vlan_id": basetypes.Int64Type{},
			"enabled":         basetypes.BoolType{},
			"local_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"type": basetypes.StringType{},
			"vlans": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	vlansVal, d := types.MapValue(types.StringType, v.Vlans.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"default_vlan_id": basetypes.Int64Type{},
			"enabled":         basetypes.BoolType{},
			"local_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"type": basetypes.StringType{},
			"vlans": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"default_vlan_id": basetypes.Int64Type{},
		"enabled":         basetypes.BoolType{},
		"local_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"type": basetypes.StringType{},
		"vlans": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_vlan_id": v.DefaultVlanId,
			"enabled":         v.Enabled,
			"local_vlan_ids":  localVlanIdsVal,
			"type":            v.DynamicVlanType,
			"vlans":           vlansVal,
		})

	return objVal, diags
}

func (v DynamicVlanValue) Equal(o attr.Value) bool {
	other, ok := o.(DynamicVlanValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultVlanId.Equal(other.DefaultVlanId) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.LocalVlanIds.Equal(other.LocalVlanIds) {
		return false
	}

	if !v.DynamicVlanType.Equal(other.DynamicVlanType) {
		return false
	}

	if !v.Vlans.Equal(other.Vlans) {
		return false
	}

	return true
}

func (v DynamicVlanValue) Type(ctx context.Context) attr.Type {
	return DynamicVlanType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DynamicVlanValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_vlan_id": basetypes.Int64Type{},
		"enabled":         basetypes.BoolType{},
		"local_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"type": basetypes.StringType{},
		"vlans": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Hotspot20Type{}

type Hotspot20Type struct {
	basetypes.ObjectType
}

func (t Hotspot20Type) Equal(o attr.Type) bool {
	other, ok := o.(Hotspot20Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Hotspot20Type) String() string {
	return "Hotspot20Type"
}

func (t Hotspot20Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	domainNameAttribute, ok := attributes["domain_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_name is missing from object`)

		return nil, diags
	}

	domainNameVal, ok := domainNameAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_name expected to be basetypes.ListValue, was: %T`, domainNameAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	naiRealmsAttribute, ok := attributes["nai_realms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nai_realms is missing from object`)

		return nil, diags
	}

	naiRealmsVal, ok := naiRealmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nai_realms expected to be basetypes.ListValue, was: %T`, naiRealmsAttribute))
	}

	operatorsAttribute, ok := attributes["operators"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operators is missing from object`)

		return nil, diags
	}

	operatorsVal, ok := operatorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operators expected to be basetypes.ListValue, was: %T`, operatorsAttribute))
	}

	rcoiAttribute, ok := attributes["rcoi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rcoi is missing from object`)

		return nil, diags
	}

	rcoiVal, ok := rcoiAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rcoi expected to be basetypes.ListValue, was: %T`, rcoiAttribute))
	}

	venueNameAttribute, ok := attributes["venue_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`venue_name is missing from object`)

		return nil, diags
	}

	venueNameVal, ok := venueNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`venue_name expected to be basetypes.StringValue, was: %T`, venueNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Hotspot20Value{
		DomainName: domainNameVal,
		Enabled:    enabledVal,
		NaiRealms:  naiRealmsVal,
		Operators:  operatorsVal,
		Rcoi:       rcoiVal,
		VenueName:  venueNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewHotspot20ValueNull() Hotspot20Value {
	return Hotspot20Value{
		state: attr.ValueStateNull,
	}
}

func NewHotspot20ValueUnknown() Hotspot20Value {
	return Hotspot20Value{
		state: attr.ValueStateUnknown,
	}
}

func NewHotspot20Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Hotspot20Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Hotspot20Value Attribute Value",
				"While creating a Hotspot20Value value, a missing attribute value was detected. "+
					"A Hotspot20Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Hotspot20Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Hotspot20Value Attribute Type",
				"While creating a Hotspot20Value value, an invalid attribute value was detected. "+
					"A Hotspot20Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Hotspot20Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Hotspot20Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Hotspot20Value Attribute Value",
				"While creating a Hotspot20Value value, an extra attribute value was detected. "+
					"A Hotspot20Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Hotspot20Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHotspot20ValueUnknown(), diags
	}

	domainNameAttribute, ok := attributes["domain_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_name is missing from object`)

		return NewHotspot20ValueUnknown(), diags
	}

	domainNameVal, ok := domainNameAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_name expected to be basetypes.ListValue, was: %T`, domainNameAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewHotspot20ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	naiRealmsAttribute, ok := attributes["nai_realms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nai_realms is missing from object`)

		return NewHotspot20ValueUnknown(), diags
	}

	naiRealmsVal, ok := naiRealmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nai_realms expected to be basetypes.ListValue, was: %T`, naiRealmsAttribute))
	}

	operatorsAttribute, ok := attributes["operators"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operators is missing from object`)

		return NewHotspot20ValueUnknown(), diags
	}

	operatorsVal, ok := operatorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operators expected to be basetypes.ListValue, was: %T`, operatorsAttribute))
	}

	rcoiAttribute, ok := attributes["rcoi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rcoi is missing from object`)

		return NewHotspot20ValueUnknown(), diags
	}

	rcoiVal, ok := rcoiAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rcoi expected to be basetypes.ListValue, was: %T`, rcoiAttribute))
	}

	venueNameAttribute, ok := attributes["venue_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`venue_name is missing from object`)

		return NewHotspot20ValueUnknown(), diags
	}

	venueNameVal, ok := venueNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`venue_name expected to be basetypes.StringValue, was: %T`, venueNameAttribute))
	}

	if diags.HasError() {
		return NewHotspot20ValueUnknown(), diags
	}

	return Hotspot20Value{
		DomainName: domainNameVal,
		Enabled:    enabledVal,
		NaiRealms:  naiRealmsVal,
		Operators:  operatorsVal,
		Rcoi:       rcoiVal,
		VenueName:  venueNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewHotspot20ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Hotspot20Value {
	object, diags := NewHotspot20Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHotspot20ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Hotspot20Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHotspot20ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHotspot20ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHotspot20ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHotspot20ValueMust(Hotspot20Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Hotspot20Type) ValueType(ctx context.Context) attr.Value {
	return Hotspot20Value{}
}

var _ basetypes.ObjectValuable = Hotspot20Value{}

type Hotspot20Value struct {
	DomainName basetypes.ListValue   `tfsdk:"domain_name"`
	Enabled    basetypes.BoolValue   `tfsdk:"enabled"`
	NaiRealms  basetypes.ListValue   `tfsdk:"nai_realms"`
	Operators  basetypes.ListValue   `tfsdk:"operators"`
	Rcoi       basetypes.ListValue   `tfsdk:"rcoi"`
	VenueName  basetypes.StringValue `tfsdk:"venue_name"`
	state      attr.ValueState
}

func (v Hotspot20Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["domain_name"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["nai_realms"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["operators"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["rcoi"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["venue_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.DomainName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["domain_name"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.NaiRealms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nai_realms"] = val

		val, err = v.Operators.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operators"] = val

		val, err = v.Rcoi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rcoi"] = val

		val, err = v.VenueName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["venue_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Hotspot20Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Hotspot20Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Hotspot20Value) String() string {
	return "Hotspot20Value"
}

func (v Hotspot20Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	domainNameVal, d := types.ListValue(types.StringType, v.DomainName.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"domain_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
			"nai_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"operators": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rcoi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"venue_name": basetypes.StringType{},
		}), diags
	}

	naiRealmsVal, d := types.ListValue(types.StringType, v.NaiRealms.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"domain_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
			"nai_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"operators": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rcoi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"venue_name": basetypes.StringType{},
		}), diags
	}

	operatorsVal, d := types.ListValue(types.StringType, v.Operators.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"domain_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
			"nai_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"operators": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rcoi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"venue_name": basetypes.StringType{},
		}), diags
	}

	rcoiVal, d := types.ListValue(types.StringType, v.Rcoi.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"domain_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
			"nai_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"operators": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rcoi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"venue_name": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"domain_name": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
		"nai_realms": basetypes.ListType{
			ElemType: types.StringType,
		},
		"operators": basetypes.ListType{
			ElemType: types.StringType,
		},
		"rcoi": basetypes.ListType{
			ElemType: types.StringType,
		},
		"venue_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"domain_name": domainNameVal,
			"enabled":     v.Enabled,
			"nai_realms":  naiRealmsVal,
			"operators":   operatorsVal,
			"rcoi":        rcoiVal,
			"venue_name":  v.VenueName,
		})

	return objVal, diags
}

func (v Hotspot20Value) Equal(o attr.Value) bool {
	other, ok := o.(Hotspot20Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DomainName.Equal(other.DomainName) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.NaiRealms.Equal(other.NaiRealms) {
		return false
	}

	if !v.Operators.Equal(other.Operators) {
		return false
	}

	if !v.Rcoi.Equal(other.Rcoi) {
		return false
	}

	if !v.VenueName.Equal(other.VenueName) {
		return false
	}

	return true
}

func (v Hotspot20Value) Type(ctx context.Context) attr.Type {
	return Hotspot20Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Hotspot20Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"domain_name": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
		"nai_realms": basetypes.ListType{
			ElemType: types.StringType,
		},
		"operators": basetypes.ListType{
			ElemType: types.StringType,
		},
		"rcoi": basetypes.ListType{
			ElemType: types.StringType,
		},
		"venue_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InjectDhcpOption82Type{}

type InjectDhcpOption82Type struct {
	basetypes.ObjectType
}

func (t InjectDhcpOption82Type) Equal(o attr.Type) bool {
	other, ok := o.(InjectDhcpOption82Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InjectDhcpOption82Type) String() string {
	return "InjectDhcpOption82Type"
}

func (t InjectDhcpOption82Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	circuitIdAttribute, ok := attributes["circuit_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`circuit_id is missing from object`)

		return nil, diags
	}

	circuitIdVal, ok := circuitIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`circuit_id expected to be basetypes.StringValue, was: %T`, circuitIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InjectDhcpOption82Value{
		CircuitId: circuitIdVal,
		Enabled:   enabledVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewInjectDhcpOption82ValueNull() InjectDhcpOption82Value {
	return InjectDhcpOption82Value{
		state: attr.ValueStateNull,
	}
}

func NewInjectDhcpOption82ValueUnknown() InjectDhcpOption82Value {
	return InjectDhcpOption82Value{
		state: attr.ValueStateUnknown,
	}
}

func NewInjectDhcpOption82Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InjectDhcpOption82Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InjectDhcpOption82Value Attribute Value",
				"While creating a InjectDhcpOption82Value value, a missing attribute value was detected. "+
					"A InjectDhcpOption82Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InjectDhcpOption82Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InjectDhcpOption82Value Attribute Type",
				"While creating a InjectDhcpOption82Value value, an invalid attribute value was detected. "+
					"A InjectDhcpOption82Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InjectDhcpOption82Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InjectDhcpOption82Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InjectDhcpOption82Value Attribute Value",
				"While creating a InjectDhcpOption82Value value, an extra attribute value was detected. "+
					"A InjectDhcpOption82Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InjectDhcpOption82Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInjectDhcpOption82ValueUnknown(), diags
	}

	circuitIdAttribute, ok := attributes["circuit_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`circuit_id is missing from object`)

		return NewInjectDhcpOption82ValueUnknown(), diags
	}

	circuitIdVal, ok := circuitIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`circuit_id expected to be basetypes.StringValue, was: %T`, circuitIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewInjectDhcpOption82ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewInjectDhcpOption82ValueUnknown(), diags
	}

	return InjectDhcpOption82Value{
		CircuitId: circuitIdVal,
		Enabled:   enabledVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewInjectDhcpOption82ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InjectDhcpOption82Value {
	object, diags := NewInjectDhcpOption82Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInjectDhcpOption82ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InjectDhcpOption82Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInjectDhcpOption82ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInjectDhcpOption82ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInjectDhcpOption82ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInjectDhcpOption82ValueMust(InjectDhcpOption82Value{}.AttributeTypes(ctx), attributes), nil
}

func (t InjectDhcpOption82Type) ValueType(ctx context.Context) attr.Value {
	return InjectDhcpOption82Value{}
}

var _ basetypes.ObjectValuable = InjectDhcpOption82Value{}

type InjectDhcpOption82Value struct {
	CircuitId basetypes.StringValue `tfsdk:"circuit_id"`
	Enabled   basetypes.BoolValue   `tfsdk:"enabled"`
	state     attr.ValueState
}

func (v InjectDhcpOption82Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["circuit_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CircuitId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["circuit_id"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InjectDhcpOption82Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InjectDhcpOption82Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InjectDhcpOption82Value) String() string {
	return "InjectDhcpOption82Value"
}

func (v InjectDhcpOption82Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"circuit_id": basetypes.StringType{},
		"enabled":    basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"circuit_id": v.CircuitId,
			"enabled":    v.Enabled,
		})

	return objVal, diags
}

func (v InjectDhcpOption82Value) Equal(o attr.Value) bool {
	other, ok := o.(InjectDhcpOption82Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CircuitId.Equal(other.CircuitId) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v InjectDhcpOption82Value) Type(ctx context.Context) attr.Type {
	return InjectDhcpOption82Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InjectDhcpOption82Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"circuit_id": basetypes.StringType{},
		"enabled":    basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MistNacType{}

type MistNacType struct {
	basetypes.ObjectType
}

func (t MistNacType) Equal(o attr.Type) bool {
	other, ok := o.(MistNacType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MistNacType) String() string {
	return "MistNacType"
}

func (t MistNacType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MistNacValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueNull() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateNull,
	}
}

func NewMistNacValueUnknown() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMistNacValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MistNacValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MistNacValue Attribute Value",
				"While creating a MistNacValue value, a missing attribute value was detected. "+
					"A MistNacValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MistNacValue Attribute Type",
				"While creating a MistNacValue value, an invalid attribute value was detected. "+
					"A MistNacValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MistNacValue Attribute Value",
				"While creating a MistNacValue value, an extra attribute value was detected. "+
					"A MistNacValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MistNacValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	return MistNacValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MistNacValue {
	object, diags := NewMistNacValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMistNacValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MistNacType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMistNacValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMistNacValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMistNacValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMistNacValueMust(MistNacValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MistNacType) ValueType(ctx context.Context) attr.Value {
	return MistNacValue{}
}

var _ basetypes.ObjectValuable = MistNacValue{}

type MistNacValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v MistNacValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MistNacValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MistNacValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MistNacValue) String() string {
	return "MistNacValue"
}

func (v MistNacValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v MistNacValue) Equal(o attr.Value) bool {
	other, ok := o.(MistNacValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v MistNacValue) Type(ctx context.Context) attr.Type {
	return MistNacType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MistNacValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PortalType{}

type PortalType struct {
	basetypes.ObjectType
}

func (t PortalType) Equal(o attr.Type) bool {
	other, ok := o.(PortalType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortalType) String() string {
	return "PortalType"
}

func (t PortalType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amazonClientIdAttribute, ok := attributes["amazon_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_client_id is missing from object`)

		return nil, diags
	}

	amazonClientIdVal, ok := amazonClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_client_id expected to be basetypes.StringValue, was: %T`, amazonClientIdAttribute))
	}

	amazonClientSecretAttribute, ok := attributes["amazon_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_client_secret is missing from object`)

		return nil, diags
	}

	amazonClientSecretVal, ok := amazonClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_client_secret expected to be basetypes.StringValue, was: %T`, amazonClientSecretAttribute))
	}

	amazonEmailDomainsAttribute, ok := attributes["amazon_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_email_domains is missing from object`)

		return nil, diags
	}

	amazonEmailDomainsVal, ok := amazonEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_email_domains expected to be basetypes.ListValue, was: %T`, amazonEmailDomainsAttribute))
	}

	amazonEnabledAttribute, ok := attributes["amazon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_enabled is missing from object`)

		return nil, diags
	}

	amazonEnabledVal, ok := amazonEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_enabled expected to be basetypes.BoolValue, was: %T`, amazonEnabledAttribute))
	}

	amazonExpireAttribute, ok := attributes["amazon_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_expire is missing from object`)

		return nil, diags
	}

	amazonExpireVal, ok := amazonExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_expire expected to be basetypes.Float64Value, was: %T`, amazonExpireAttribute))
	}

	authAttribute, ok := attributes["auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth is missing from object`)

		return nil, diags
	}

	authVal, ok := authAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth expected to be basetypes.StringValue, was: %T`, authAttribute))
	}

	azureClientIdAttribute, ok := attributes["azure_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_client_id is missing from object`)

		return nil, diags
	}

	azureClientIdVal, ok := azureClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_client_id expected to be basetypes.StringValue, was: %T`, azureClientIdAttribute))
	}

	azureClientSecretAttribute, ok := attributes["azure_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_client_secret is missing from object`)

		return nil, diags
	}

	azureClientSecretVal, ok := azureClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_client_secret expected to be basetypes.StringValue, was: %T`, azureClientSecretAttribute))
	}

	azureEnabledAttribute, ok := attributes["azure_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_enabled is missing from object`)

		return nil, diags
	}

	azureEnabledVal, ok := azureEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_enabled expected to be basetypes.BoolValue, was: %T`, azureEnabledAttribute))
	}

	azureExpireAttribute, ok := attributes["azure_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_expire is missing from object`)

		return nil, diags
	}

	azureExpireVal, ok := azureExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_expire expected to be basetypes.Float64Value, was: %T`, azureExpireAttribute))
	}

	azureTenantIdAttribute, ok := attributes["azure_tenant_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_tenant_id is missing from object`)

		return nil, diags
	}

	azureTenantIdVal, ok := azureTenantIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_tenant_id expected to be basetypes.StringValue, was: %T`, azureTenantIdAttribute))
	}

	broadnetPasswordAttribute, ok := attributes["broadnet_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadnet_password is missing from object`)

		return nil, diags
	}

	broadnetPasswordVal, ok := broadnetPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadnet_password expected to be basetypes.StringValue, was: %T`, broadnetPasswordAttribute))
	}

	broadnetSidAttribute, ok := attributes["broadnet_sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadnet_sid is missing from object`)

		return nil, diags
	}

	broadnetSidVal, ok := broadnetSidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadnet_sid expected to be basetypes.StringValue, was: %T`, broadnetSidAttribute))
	}

	broadnetUserIdAttribute, ok := attributes["broadnet_user_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadnet_user_id is missing from object`)

		return nil, diags
	}

	broadnetUserIdVal, ok := broadnetUserIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadnet_user_id expected to be basetypes.StringValue, was: %T`, broadnetUserIdAttribute))
	}

	bypassWhenCloudDownAttribute, ok := attributes["bypass_when_cloud_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_when_cloud_down is missing from object`)

		return nil, diags
	}

	bypassWhenCloudDownVal, ok := bypassWhenCloudDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_when_cloud_down expected to be basetypes.BoolValue, was: %T`, bypassWhenCloudDownAttribute))
	}

	clickatellApiKeyAttribute, ok := attributes["clickatell_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clickatell_api_key is missing from object`)

		return nil, diags
	}

	clickatellApiKeyVal, ok := clickatellApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clickatell_api_key expected to be basetypes.StringValue, was: %T`, clickatellApiKeyAttribute))
	}

	crossSiteAttribute, ok := attributes["cross_site"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cross_site is missing from object`)

		return nil, diags
	}

	crossSiteVal, ok := crossSiteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cross_site expected to be basetypes.BoolValue, was: %T`, crossSiteAttribute))
	}

	emailEnabledAttribute, ok := attributes["email_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email_enabled is missing from object`)

		return nil, diags
	}

	emailEnabledVal, ok := emailEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email_enabled expected to be basetypes.BoolValue, was: %T`, emailEnabledAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	expireAttribute, ok := attributes["expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expire is missing from object`)

		return nil, diags
	}

	expireVal, ok := expireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expire expected to be basetypes.Float64Value, was: %T`, expireAttribute))
	}

	externalPortalUrlAttribute, ok := attributes["external_portal_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_portal_url is missing from object`)

		return nil, diags
	}

	externalPortalUrlVal, ok := externalPortalUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_portal_url expected to be basetypes.StringValue, was: %T`, externalPortalUrlAttribute))
	}

	facebookClientIdAttribute, ok := attributes["facebook_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_client_id is missing from object`)

		return nil, diags
	}

	facebookClientIdVal, ok := facebookClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_client_id expected to be basetypes.StringValue, was: %T`, facebookClientIdAttribute))
	}

	facebookClientSecretAttribute, ok := attributes["facebook_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_client_secret is missing from object`)

		return nil, diags
	}

	facebookClientSecretVal, ok := facebookClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_client_secret expected to be basetypes.StringValue, was: %T`, facebookClientSecretAttribute))
	}

	facebookEmailDomainsAttribute, ok := attributes["facebook_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_email_domains is missing from object`)

		return nil, diags
	}

	facebookEmailDomainsVal, ok := facebookEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_email_domains expected to be basetypes.ListValue, was: %T`, facebookEmailDomainsAttribute))
	}

	facebookEnabledAttribute, ok := attributes["facebook_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_enabled is missing from object`)

		return nil, diags
	}

	facebookEnabledVal, ok := facebookEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_enabled expected to be basetypes.BoolValue, was: %T`, facebookEnabledAttribute))
	}

	facebookExpireAttribute, ok := attributes["facebook_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_expire is missing from object`)

		return nil, diags
	}

	facebookExpireVal, ok := facebookExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_expire expected to be basetypes.Float64Value, was: %T`, facebookExpireAttribute))
	}

	forwardAttribute, ok := attributes["forward"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forward is missing from object`)

		return nil, diags
	}

	forwardVal, ok := forwardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forward expected to be basetypes.BoolValue, was: %T`, forwardAttribute))
	}

	forwardUrlAttribute, ok := attributes["forward_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forward_url is missing from object`)

		return nil, diags
	}

	forwardUrlVal, ok := forwardUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forward_url expected to be basetypes.StringValue, was: %T`, forwardUrlAttribute))
	}

	googleClientIdAttribute, ok := attributes["google_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_client_id is missing from object`)

		return nil, diags
	}

	googleClientIdVal, ok := googleClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_client_id expected to be basetypes.StringValue, was: %T`, googleClientIdAttribute))
	}

	googleClientSecretAttribute, ok := attributes["google_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_client_secret is missing from object`)

		return nil, diags
	}

	googleClientSecretVal, ok := googleClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_client_secret expected to be basetypes.StringValue, was: %T`, googleClientSecretAttribute))
	}

	googleEmailDomainsAttribute, ok := attributes["google_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_email_domains is missing from object`)

		return nil, diags
	}

	googleEmailDomainsVal, ok := googleEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_email_domains expected to be basetypes.ListValue, was: %T`, googleEmailDomainsAttribute))
	}

	googleEnabledAttribute, ok := attributes["google_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_enabled is missing from object`)

		return nil, diags
	}

	googleEnabledVal, ok := googleEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_enabled expected to be basetypes.BoolValue, was: %T`, googleEnabledAttribute))
	}

	googleExpireAttribute, ok := attributes["google_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_expire is missing from object`)

		return nil, diags
	}

	googleExpireVal, ok := googleExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_expire expected to be basetypes.Float64Value, was: %T`, googleExpireAttribute))
	}

	gupshupPasswordAttribute, ok := attributes["gupshup_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gupshup_password is missing from object`)

		return nil, diags
	}

	gupshupPasswordVal, ok := gupshupPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gupshup_password expected to be basetypes.StringValue, was: %T`, gupshupPasswordAttribute))
	}

	gupshupUseridAttribute, ok := attributes["gupshup_userid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gupshup_userid is missing from object`)

		return nil, diags
	}

	gupshupUseridVal, ok := gupshupUseridAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gupshup_userid expected to be basetypes.StringValue, was: %T`, gupshupUseridAttribute))
	}

	microsoftClientIdAttribute, ok := attributes["microsoft_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_client_id is missing from object`)

		return nil, diags
	}

	microsoftClientIdVal, ok := microsoftClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_client_id expected to be basetypes.StringValue, was: %T`, microsoftClientIdAttribute))
	}

	microsoftClientSecretAttribute, ok := attributes["microsoft_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_client_secret is missing from object`)

		return nil, diags
	}

	microsoftClientSecretVal, ok := microsoftClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_client_secret expected to be basetypes.StringValue, was: %T`, microsoftClientSecretAttribute))
	}

	microsoftEmailDomainsAttribute, ok := attributes["microsoft_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_email_domains is missing from object`)

		return nil, diags
	}

	microsoftEmailDomainsVal, ok := microsoftEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_email_domains expected to be basetypes.ListValue, was: %T`, microsoftEmailDomainsAttribute))
	}

	microsoftEnabledAttribute, ok := attributes["microsoft_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_enabled is missing from object`)

		return nil, diags
	}

	microsoftEnabledVal, ok := microsoftEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_enabled expected to be basetypes.BoolValue, was: %T`, microsoftEnabledAttribute))
	}

	microsoftExpireAttribute, ok := attributes["microsoft_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_expire is missing from object`)

		return nil, diags
	}

	microsoftExpireVal, ok := microsoftExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_expire expected to be basetypes.Float64Value, was: %T`, microsoftExpireAttribute))
	}

	passphraseEnabledAttribute, ok := attributes["passphrase_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passphrase_enabled is missing from object`)

		return nil, diags
	}

	passphraseEnabledVal, ok := passphraseEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passphrase_enabled expected to be basetypes.BoolValue, was: %T`, passphraseEnabledAttribute))
	}

	passphraseExpireAttribute, ok := attributes["passphrase_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passphrase_expire is missing from object`)

		return nil, diags
	}

	passphraseExpireVal, ok := passphraseExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passphrase_expire expected to be basetypes.Float64Value, was: %T`, passphraseExpireAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portalApiSecretAttribute, ok := attributes["portal_api_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_api_secret is missing from object`)

		return nil, diags
	}

	portalApiSecretVal, ok := portalApiSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_api_secret expected to be basetypes.StringValue, was: %T`, portalApiSecretAttribute))
	}

	portalImageAttribute, ok := attributes["portal_image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_image is missing from object`)

		return nil, diags
	}

	portalImageVal, ok := portalImageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_image expected to be basetypes.StringValue, was: %T`, portalImageAttribute))
	}

	portalSsoUrlAttribute, ok := attributes["portal_sso_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_sso_url is missing from object`)

		return nil, diags
	}

	portalSsoUrlVal, ok := portalSsoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_sso_url expected to be basetypes.StringValue, was: %T`, portalSsoUrlAttribute))
	}

	predefinedSponsorsEnabledAttribute, ok := attributes["predefined_sponsors_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`predefined_sponsors_enabled is missing from object`)

		return nil, diags
	}

	predefinedSponsorsEnabledVal, ok := predefinedSponsorsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`predefined_sponsors_enabled expected to be basetypes.BoolValue, was: %T`, predefinedSponsorsEnabledAttribute))
	}

	privacyAttribute, ok := attributes["privacy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`privacy is missing from object`)

		return nil, diags
	}

	privacyVal, ok := privacyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`privacy expected to be basetypes.BoolValue, was: %T`, privacyAttribute))
	}

	puzzelPasswordAttribute, ok := attributes["puzzel_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`puzzel_password is missing from object`)

		return nil, diags
	}

	puzzelPasswordVal, ok := puzzelPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`puzzel_password expected to be basetypes.StringValue, was: %T`, puzzelPasswordAttribute))
	}

	puzzelServiceIdAttribute, ok := attributes["puzzel_service_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`puzzel_service_id is missing from object`)

		return nil, diags
	}

	puzzelServiceIdVal, ok := puzzelServiceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`puzzel_service_id expected to be basetypes.StringValue, was: %T`, puzzelServiceIdAttribute))
	}

	puzzelUsernameAttribute, ok := attributes["puzzel_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`puzzel_username is missing from object`)

		return nil, diags
	}

	puzzelUsernameVal, ok := puzzelUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`puzzel_username expected to be basetypes.StringValue, was: %T`, puzzelUsernameAttribute))
	}

	smsEnabledAttribute, ok := attributes["sms_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_enabled is missing from object`)

		return nil, diags
	}

	smsEnabledVal, ok := smsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_enabled expected to be basetypes.BoolValue, was: %T`, smsEnabledAttribute))
	}

	smsExpireAttribute, ok := attributes["sms_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_expire is missing from object`)

		return nil, diags
	}

	smsExpireVal, ok := smsExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_expire expected to be basetypes.Float64Value, was: %T`, smsExpireAttribute))
	}

	smsMessageFormatAttribute, ok := attributes["sms_message_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_message_format is missing from object`)

		return nil, diags
	}

	smsMessageFormatVal, ok := smsMessageFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_message_format expected to be basetypes.StringValue, was: %T`, smsMessageFormatAttribute))
	}

	smsProviderAttribute, ok := attributes["sms_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_provider is missing from object`)

		return nil, diags
	}

	smsProviderVal, ok := smsProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_provider expected to be basetypes.StringValue, was: %T`, smsProviderAttribute))
	}

	sponsorAutoApproveAttribute, ok := attributes["sponsor_auto_approve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_auto_approve is missing from object`)

		return nil, diags
	}

	sponsorAutoApproveVal, ok := sponsorAutoApproveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_auto_approve expected to be basetypes.BoolValue, was: %T`, sponsorAutoApproveAttribute))
	}

	sponsorEmailDomainsAttribute, ok := attributes["sponsor_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_email_domains is missing from object`)

		return nil, diags
	}

	sponsorEmailDomainsVal, ok := sponsorEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_email_domains expected to be basetypes.ListValue, was: %T`, sponsorEmailDomainsAttribute))
	}

	sponsorEnabledAttribute, ok := attributes["sponsor_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_enabled is missing from object`)

		return nil, diags
	}

	sponsorEnabledVal, ok := sponsorEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_enabled expected to be basetypes.BoolValue, was: %T`, sponsorEnabledAttribute))
	}

	sponsorExpireAttribute, ok := attributes["sponsor_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_expire is missing from object`)

		return nil, diags
	}

	sponsorExpireVal, ok := sponsorExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_expire expected to be basetypes.Float64Value, was: %T`, sponsorExpireAttribute))
	}

	sponsorLinkValidityDurationAttribute, ok := attributes["sponsor_link_validity_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_link_validity_duration is missing from object`)

		return nil, diags
	}

	sponsorLinkValidityDurationVal, ok := sponsorLinkValidityDurationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_link_validity_duration expected to be basetypes.Int64Value, was: %T`, sponsorLinkValidityDurationAttribute))
	}

	sponsorNotifyAllAttribute, ok := attributes["sponsor_notify_all"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_notify_all is missing from object`)

		return nil, diags
	}

	sponsorNotifyAllVal, ok := sponsorNotifyAllAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_notify_all expected to be basetypes.BoolValue, was: %T`, sponsorNotifyAllAttribute))
	}

	sponsorStatusNotifyAttribute, ok := attributes["sponsor_status_notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_status_notify is missing from object`)

		return nil, diags
	}

	sponsorStatusNotifyVal, ok := sponsorStatusNotifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_status_notify expected to be basetypes.BoolValue, was: %T`, sponsorStatusNotifyAttribute))
	}

	sponsorsAttribute, ok := attributes["sponsors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsors is missing from object`)

		return nil, diags
	}

	sponsorsVal, ok := sponsorsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsors expected to be basetypes.MapValue, was: %T`, sponsorsAttribute))
	}

	ssoDefaultRoleAttribute, ok := attributes["sso_default_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_default_role is missing from object`)

		return nil, diags
	}

	ssoDefaultRoleVal, ok := ssoDefaultRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_default_role expected to be basetypes.StringValue, was: %T`, ssoDefaultRoleAttribute))
	}

	ssoForcedRoleAttribute, ok := attributes["sso_forced_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_forced_role is missing from object`)

		return nil, diags
	}

	ssoForcedRoleVal, ok := ssoForcedRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_forced_role expected to be basetypes.StringValue, was: %T`, ssoForcedRoleAttribute))
	}

	ssoIdpCertAttribute, ok := attributes["sso_idp_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_idp_cert is missing from object`)

		return nil, diags
	}

	ssoIdpCertVal, ok := ssoIdpCertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_idp_cert expected to be basetypes.StringValue, was: %T`, ssoIdpCertAttribute))
	}

	ssoIdpSignAlgoAttribute, ok := attributes["sso_idp_sign_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_idp_sign_algo is missing from object`)

		return nil, diags
	}

	ssoIdpSignAlgoVal, ok := ssoIdpSignAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_idp_sign_algo expected to be basetypes.StringValue, was: %T`, ssoIdpSignAlgoAttribute))
	}

	ssoIdpSsoUrlAttribute, ok := attributes["sso_idp_sso_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_idp_sso_url is missing from object`)

		return nil, diags
	}

	ssoIdpSsoUrlVal, ok := ssoIdpSsoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_idp_sso_url expected to be basetypes.StringValue, was: %T`, ssoIdpSsoUrlAttribute))
	}

	ssoIssuerAttribute, ok := attributes["sso_issuer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_issuer is missing from object`)

		return nil, diags
	}

	ssoIssuerVal, ok := ssoIssuerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_issuer expected to be basetypes.StringValue, was: %T`, ssoIssuerAttribute))
	}

	ssoNameidFormatAttribute, ok := attributes["sso_nameid_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_nameid_format is missing from object`)

		return nil, diags
	}

	ssoNameidFormatVal, ok := ssoNameidFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_nameid_format expected to be basetypes.StringValue, was: %T`, ssoNameidFormatAttribute))
	}

	telstraClientIdAttribute, ok := attributes["telstra_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`telstra_client_id is missing from object`)

		return nil, diags
	}

	telstraClientIdVal, ok := telstraClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`telstra_client_id expected to be basetypes.StringValue, was: %T`, telstraClientIdAttribute))
	}

	telstraClientSecretAttribute, ok := attributes["telstra_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`telstra_client_secret is missing from object`)

		return nil, diags
	}

	telstraClientSecretVal, ok := telstraClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`telstra_client_secret expected to be basetypes.StringValue, was: %T`, telstraClientSecretAttribute))
	}

	twilioAuthTokenAttribute, ok := attributes["twilio_auth_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`twilio_auth_token is missing from object`)

		return nil, diags
	}

	twilioAuthTokenVal, ok := twilioAuthTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`twilio_auth_token expected to be basetypes.StringValue, was: %T`, twilioAuthTokenAttribute))
	}

	twilioPhoneNumberAttribute, ok := attributes["twilio_phone_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`twilio_phone_number is missing from object`)

		return nil, diags
	}

	twilioPhoneNumberVal, ok := twilioPhoneNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`twilio_phone_number expected to be basetypes.StringValue, was: %T`, twilioPhoneNumberAttribute))
	}

	twilioSidAttribute, ok := attributes["twilio_sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`twilio_sid is missing from object`)

		return nil, diags
	}

	twilioSidVal, ok := twilioSidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`twilio_sid expected to be basetypes.StringValue, was: %T`, twilioSidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortalValue{
		AmazonClientId:              amazonClientIdVal,
		AmazonClientSecret:          amazonClientSecretVal,
		AmazonEmailDomains:          amazonEmailDomainsVal,
		AmazonEnabled:               amazonEnabledVal,
		AmazonExpire:                amazonExpireVal,
		Auth:                        authVal,
		AzureClientId:               azureClientIdVal,
		AzureClientSecret:           azureClientSecretVal,
		AzureEnabled:                azureEnabledVal,
		AzureExpire:                 azureExpireVal,
		AzureTenantId:               azureTenantIdVal,
		BroadnetPassword:            broadnetPasswordVal,
		BroadnetSid:                 broadnetSidVal,
		BroadnetUserId:              broadnetUserIdVal,
		BypassWhenCloudDown:         bypassWhenCloudDownVal,
		ClickatellApiKey:            clickatellApiKeyVal,
		CrossSite:                   crossSiteVal,
		EmailEnabled:                emailEnabledVal,
		Enabled:                     enabledVal,
		Expire:                      expireVal,
		ExternalPortalUrl:           externalPortalUrlVal,
		FacebookClientId:            facebookClientIdVal,
		FacebookClientSecret:        facebookClientSecretVal,
		FacebookEmailDomains:        facebookEmailDomainsVal,
		FacebookEnabled:             facebookEnabledVal,
		FacebookExpire:              facebookExpireVal,
		Forward:                     forwardVal,
		ForwardUrl:                  forwardUrlVal,
		GoogleClientId:              googleClientIdVal,
		GoogleClientSecret:          googleClientSecretVal,
		GoogleEmailDomains:          googleEmailDomainsVal,
		GoogleEnabled:               googleEnabledVal,
		GoogleExpire:                googleExpireVal,
		GupshupPassword:             gupshupPasswordVal,
		GupshupUserid:               gupshupUseridVal,
		MicrosoftClientId:           microsoftClientIdVal,
		MicrosoftClientSecret:       microsoftClientSecretVal,
		MicrosoftEmailDomains:       microsoftEmailDomainsVal,
		MicrosoftEnabled:            microsoftEnabledVal,
		MicrosoftExpire:             microsoftExpireVal,
		PassphraseEnabled:           passphraseEnabledVal,
		PassphraseExpire:            passphraseExpireVal,
		Password:                    passwordVal,
		PortalApiSecret:             portalApiSecretVal,
		PortalImage:                 portalImageVal,
		PortalSsoUrl:                portalSsoUrlVal,
		PredefinedSponsorsEnabled:   predefinedSponsorsEnabledVal,
		Privacy:                     privacyVal,
		PuzzelPassword:              puzzelPasswordVal,
		PuzzelServiceId:             puzzelServiceIdVal,
		PuzzelUsername:              puzzelUsernameVal,
		SmsEnabled:                  smsEnabledVal,
		SmsExpire:                   smsExpireVal,
		SmsMessageFormat:            smsMessageFormatVal,
		SmsProvider:                 smsProviderVal,
		SponsorAutoApprove:          sponsorAutoApproveVal,
		SponsorEmailDomains:         sponsorEmailDomainsVal,
		SponsorEnabled:              sponsorEnabledVal,
		SponsorExpire:               sponsorExpireVal,
		SponsorLinkValidityDuration: sponsorLinkValidityDurationVal,
		SponsorNotifyAll:            sponsorNotifyAllVal,
		SponsorStatusNotify:         sponsorStatusNotifyVal,
		Sponsors:                    sponsorsVal,
		SsoDefaultRole:              ssoDefaultRoleVal,
		SsoForcedRole:               ssoForcedRoleVal,
		SsoIdpCert:                  ssoIdpCertVal,
		SsoIdpSignAlgo:              ssoIdpSignAlgoVal,
		SsoIdpSsoUrl:                ssoIdpSsoUrlVal,
		SsoIssuer:                   ssoIssuerVal,
		SsoNameidFormat:             ssoNameidFormatVal,
		TelstraClientId:             telstraClientIdVal,
		TelstraClientSecret:         telstraClientSecretVal,
		TwilioAuthToken:             twilioAuthTokenVal,
		TwilioPhoneNumber:           twilioPhoneNumberVal,
		TwilioSid:                   twilioSidVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewPortalValueNull() PortalValue {
	return PortalValue{
		state: attr.ValueStateNull,
	}
}

func NewPortalValueUnknown() PortalValue {
	return PortalValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortalValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortalValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortalValue Attribute Value",
				"While creating a PortalValue value, a missing attribute value was detected. "+
					"A PortalValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortalValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortalValue Attribute Type",
				"While creating a PortalValue value, an invalid attribute value was detected. "+
					"A PortalValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortalValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortalValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortalValue Attribute Value",
				"While creating a PortalValue value, an extra attribute value was detected. "+
					"A PortalValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortalValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortalValueUnknown(), diags
	}

	amazonClientIdAttribute, ok := attributes["amazon_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_client_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	amazonClientIdVal, ok := amazonClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_client_id expected to be basetypes.StringValue, was: %T`, amazonClientIdAttribute))
	}

	amazonClientSecretAttribute, ok := attributes["amazon_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_client_secret is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	amazonClientSecretVal, ok := amazonClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_client_secret expected to be basetypes.StringValue, was: %T`, amazonClientSecretAttribute))
	}

	amazonEmailDomainsAttribute, ok := attributes["amazon_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_email_domains is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	amazonEmailDomainsVal, ok := amazonEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_email_domains expected to be basetypes.ListValue, was: %T`, amazonEmailDomainsAttribute))
	}

	amazonEnabledAttribute, ok := attributes["amazon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	amazonEnabledVal, ok := amazonEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_enabled expected to be basetypes.BoolValue, was: %T`, amazonEnabledAttribute))
	}

	amazonExpireAttribute, ok := attributes["amazon_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	amazonExpireVal, ok := amazonExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_expire expected to be basetypes.Float64Value, was: %T`, amazonExpireAttribute))
	}

	authAttribute, ok := attributes["auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	authVal, ok := authAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth expected to be basetypes.StringValue, was: %T`, authAttribute))
	}

	azureClientIdAttribute, ok := attributes["azure_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_client_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	azureClientIdVal, ok := azureClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_client_id expected to be basetypes.StringValue, was: %T`, azureClientIdAttribute))
	}

	azureClientSecretAttribute, ok := attributes["azure_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_client_secret is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	azureClientSecretVal, ok := azureClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_client_secret expected to be basetypes.StringValue, was: %T`, azureClientSecretAttribute))
	}

	azureEnabledAttribute, ok := attributes["azure_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	azureEnabledVal, ok := azureEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_enabled expected to be basetypes.BoolValue, was: %T`, azureEnabledAttribute))
	}

	azureExpireAttribute, ok := attributes["azure_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	azureExpireVal, ok := azureExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_expire expected to be basetypes.Float64Value, was: %T`, azureExpireAttribute))
	}

	azureTenantIdAttribute, ok := attributes["azure_tenant_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_tenant_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	azureTenantIdVal, ok := azureTenantIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_tenant_id expected to be basetypes.StringValue, was: %T`, azureTenantIdAttribute))
	}

	broadnetPasswordAttribute, ok := attributes["broadnet_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadnet_password is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	broadnetPasswordVal, ok := broadnetPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadnet_password expected to be basetypes.StringValue, was: %T`, broadnetPasswordAttribute))
	}

	broadnetSidAttribute, ok := attributes["broadnet_sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadnet_sid is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	broadnetSidVal, ok := broadnetSidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadnet_sid expected to be basetypes.StringValue, was: %T`, broadnetSidAttribute))
	}

	broadnetUserIdAttribute, ok := attributes["broadnet_user_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadnet_user_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	broadnetUserIdVal, ok := broadnetUserIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadnet_user_id expected to be basetypes.StringValue, was: %T`, broadnetUserIdAttribute))
	}

	bypassWhenCloudDownAttribute, ok := attributes["bypass_when_cloud_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_when_cloud_down is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	bypassWhenCloudDownVal, ok := bypassWhenCloudDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_when_cloud_down expected to be basetypes.BoolValue, was: %T`, bypassWhenCloudDownAttribute))
	}

	clickatellApiKeyAttribute, ok := attributes["clickatell_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clickatell_api_key is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	clickatellApiKeyVal, ok := clickatellApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clickatell_api_key expected to be basetypes.StringValue, was: %T`, clickatellApiKeyAttribute))
	}

	crossSiteAttribute, ok := attributes["cross_site"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cross_site is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	crossSiteVal, ok := crossSiteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cross_site expected to be basetypes.BoolValue, was: %T`, crossSiteAttribute))
	}

	emailEnabledAttribute, ok := attributes["email_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	emailEnabledVal, ok := emailEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email_enabled expected to be basetypes.BoolValue, was: %T`, emailEnabledAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	expireAttribute, ok := attributes["expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	expireVal, ok := expireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expire expected to be basetypes.Float64Value, was: %T`, expireAttribute))
	}

	externalPortalUrlAttribute, ok := attributes["external_portal_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_portal_url is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	externalPortalUrlVal, ok := externalPortalUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_portal_url expected to be basetypes.StringValue, was: %T`, externalPortalUrlAttribute))
	}

	facebookClientIdAttribute, ok := attributes["facebook_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_client_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	facebookClientIdVal, ok := facebookClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_client_id expected to be basetypes.StringValue, was: %T`, facebookClientIdAttribute))
	}

	facebookClientSecretAttribute, ok := attributes["facebook_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_client_secret is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	facebookClientSecretVal, ok := facebookClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_client_secret expected to be basetypes.StringValue, was: %T`, facebookClientSecretAttribute))
	}

	facebookEmailDomainsAttribute, ok := attributes["facebook_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_email_domains is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	facebookEmailDomainsVal, ok := facebookEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_email_domains expected to be basetypes.ListValue, was: %T`, facebookEmailDomainsAttribute))
	}

	facebookEnabledAttribute, ok := attributes["facebook_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	facebookEnabledVal, ok := facebookEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_enabled expected to be basetypes.BoolValue, was: %T`, facebookEnabledAttribute))
	}

	facebookExpireAttribute, ok := attributes["facebook_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	facebookExpireVal, ok := facebookExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_expire expected to be basetypes.Float64Value, was: %T`, facebookExpireAttribute))
	}

	forwardAttribute, ok := attributes["forward"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forward is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	forwardVal, ok := forwardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forward expected to be basetypes.BoolValue, was: %T`, forwardAttribute))
	}

	forwardUrlAttribute, ok := attributes["forward_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forward_url is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	forwardUrlVal, ok := forwardUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forward_url expected to be basetypes.StringValue, was: %T`, forwardUrlAttribute))
	}

	googleClientIdAttribute, ok := attributes["google_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_client_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	googleClientIdVal, ok := googleClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_client_id expected to be basetypes.StringValue, was: %T`, googleClientIdAttribute))
	}

	googleClientSecretAttribute, ok := attributes["google_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_client_secret is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	googleClientSecretVal, ok := googleClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_client_secret expected to be basetypes.StringValue, was: %T`, googleClientSecretAttribute))
	}

	googleEmailDomainsAttribute, ok := attributes["google_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_email_domains is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	googleEmailDomainsVal, ok := googleEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_email_domains expected to be basetypes.ListValue, was: %T`, googleEmailDomainsAttribute))
	}

	googleEnabledAttribute, ok := attributes["google_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	googleEnabledVal, ok := googleEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_enabled expected to be basetypes.BoolValue, was: %T`, googleEnabledAttribute))
	}

	googleExpireAttribute, ok := attributes["google_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	googleExpireVal, ok := googleExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_expire expected to be basetypes.Float64Value, was: %T`, googleExpireAttribute))
	}

	gupshupPasswordAttribute, ok := attributes["gupshup_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gupshup_password is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	gupshupPasswordVal, ok := gupshupPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gupshup_password expected to be basetypes.StringValue, was: %T`, gupshupPasswordAttribute))
	}

	gupshupUseridAttribute, ok := attributes["gupshup_userid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gupshup_userid is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	gupshupUseridVal, ok := gupshupUseridAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gupshup_userid expected to be basetypes.StringValue, was: %T`, gupshupUseridAttribute))
	}

	microsoftClientIdAttribute, ok := attributes["microsoft_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_client_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	microsoftClientIdVal, ok := microsoftClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_client_id expected to be basetypes.StringValue, was: %T`, microsoftClientIdAttribute))
	}

	microsoftClientSecretAttribute, ok := attributes["microsoft_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_client_secret is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	microsoftClientSecretVal, ok := microsoftClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_client_secret expected to be basetypes.StringValue, was: %T`, microsoftClientSecretAttribute))
	}

	microsoftEmailDomainsAttribute, ok := attributes["microsoft_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_email_domains is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	microsoftEmailDomainsVal, ok := microsoftEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_email_domains expected to be basetypes.ListValue, was: %T`, microsoftEmailDomainsAttribute))
	}

	microsoftEnabledAttribute, ok := attributes["microsoft_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	microsoftEnabledVal, ok := microsoftEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_enabled expected to be basetypes.BoolValue, was: %T`, microsoftEnabledAttribute))
	}

	microsoftExpireAttribute, ok := attributes["microsoft_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	microsoftExpireVal, ok := microsoftExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_expire expected to be basetypes.Float64Value, was: %T`, microsoftExpireAttribute))
	}

	passphraseEnabledAttribute, ok := attributes["passphrase_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passphrase_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	passphraseEnabledVal, ok := passphraseEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passphrase_enabled expected to be basetypes.BoolValue, was: %T`, passphraseEnabledAttribute))
	}

	passphraseExpireAttribute, ok := attributes["passphrase_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passphrase_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	passphraseExpireVal, ok := passphraseExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passphrase_expire expected to be basetypes.Float64Value, was: %T`, passphraseExpireAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portalApiSecretAttribute, ok := attributes["portal_api_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_api_secret is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	portalApiSecretVal, ok := portalApiSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_api_secret expected to be basetypes.StringValue, was: %T`, portalApiSecretAttribute))
	}

	portalImageAttribute, ok := attributes["portal_image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_image is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	portalImageVal, ok := portalImageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_image expected to be basetypes.StringValue, was: %T`, portalImageAttribute))
	}

	portalSsoUrlAttribute, ok := attributes["portal_sso_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_sso_url is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	portalSsoUrlVal, ok := portalSsoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_sso_url expected to be basetypes.StringValue, was: %T`, portalSsoUrlAttribute))
	}

	predefinedSponsorsEnabledAttribute, ok := attributes["predefined_sponsors_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`predefined_sponsors_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	predefinedSponsorsEnabledVal, ok := predefinedSponsorsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`predefined_sponsors_enabled expected to be basetypes.BoolValue, was: %T`, predefinedSponsorsEnabledAttribute))
	}

	privacyAttribute, ok := attributes["privacy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`privacy is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	privacyVal, ok := privacyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`privacy expected to be basetypes.BoolValue, was: %T`, privacyAttribute))
	}

	puzzelPasswordAttribute, ok := attributes["puzzel_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`puzzel_password is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	puzzelPasswordVal, ok := puzzelPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`puzzel_password expected to be basetypes.StringValue, was: %T`, puzzelPasswordAttribute))
	}

	puzzelServiceIdAttribute, ok := attributes["puzzel_service_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`puzzel_service_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	puzzelServiceIdVal, ok := puzzelServiceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`puzzel_service_id expected to be basetypes.StringValue, was: %T`, puzzelServiceIdAttribute))
	}

	puzzelUsernameAttribute, ok := attributes["puzzel_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`puzzel_username is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	puzzelUsernameVal, ok := puzzelUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`puzzel_username expected to be basetypes.StringValue, was: %T`, puzzelUsernameAttribute))
	}

	smsEnabledAttribute, ok := attributes["sms_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	smsEnabledVal, ok := smsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_enabled expected to be basetypes.BoolValue, was: %T`, smsEnabledAttribute))
	}

	smsExpireAttribute, ok := attributes["sms_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	smsExpireVal, ok := smsExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_expire expected to be basetypes.Float64Value, was: %T`, smsExpireAttribute))
	}

	smsMessageFormatAttribute, ok := attributes["sms_message_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_message_format is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	smsMessageFormatVal, ok := smsMessageFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_message_format expected to be basetypes.StringValue, was: %T`, smsMessageFormatAttribute))
	}

	smsProviderAttribute, ok := attributes["sms_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_provider is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	smsProviderVal, ok := smsProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_provider expected to be basetypes.StringValue, was: %T`, smsProviderAttribute))
	}

	sponsorAutoApproveAttribute, ok := attributes["sponsor_auto_approve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_auto_approve is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorAutoApproveVal, ok := sponsorAutoApproveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_auto_approve expected to be basetypes.BoolValue, was: %T`, sponsorAutoApproveAttribute))
	}

	sponsorEmailDomainsAttribute, ok := attributes["sponsor_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_email_domains is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorEmailDomainsVal, ok := sponsorEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_email_domains expected to be basetypes.ListValue, was: %T`, sponsorEmailDomainsAttribute))
	}

	sponsorEnabledAttribute, ok := attributes["sponsor_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorEnabledVal, ok := sponsorEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_enabled expected to be basetypes.BoolValue, was: %T`, sponsorEnabledAttribute))
	}

	sponsorExpireAttribute, ok := attributes["sponsor_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorExpireVal, ok := sponsorExpireAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_expire expected to be basetypes.Float64Value, was: %T`, sponsorExpireAttribute))
	}

	sponsorLinkValidityDurationAttribute, ok := attributes["sponsor_link_validity_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_link_validity_duration is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorLinkValidityDurationVal, ok := sponsorLinkValidityDurationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_link_validity_duration expected to be basetypes.Int64Value, was: %T`, sponsorLinkValidityDurationAttribute))
	}

	sponsorNotifyAllAttribute, ok := attributes["sponsor_notify_all"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_notify_all is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorNotifyAllVal, ok := sponsorNotifyAllAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_notify_all expected to be basetypes.BoolValue, was: %T`, sponsorNotifyAllAttribute))
	}

	sponsorStatusNotifyAttribute, ok := attributes["sponsor_status_notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_status_notify is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorStatusNotifyVal, ok := sponsorStatusNotifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_status_notify expected to be basetypes.BoolValue, was: %T`, sponsorStatusNotifyAttribute))
	}

	sponsorsAttribute, ok := attributes["sponsors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsors is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorsVal, ok := sponsorsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsors expected to be basetypes.MapValue, was: %T`, sponsorsAttribute))
	}

	ssoDefaultRoleAttribute, ok := attributes["sso_default_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_default_role is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoDefaultRoleVal, ok := ssoDefaultRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_default_role expected to be basetypes.StringValue, was: %T`, ssoDefaultRoleAttribute))
	}

	ssoForcedRoleAttribute, ok := attributes["sso_forced_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_forced_role is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoForcedRoleVal, ok := ssoForcedRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_forced_role expected to be basetypes.StringValue, was: %T`, ssoForcedRoleAttribute))
	}

	ssoIdpCertAttribute, ok := attributes["sso_idp_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_idp_cert is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoIdpCertVal, ok := ssoIdpCertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_idp_cert expected to be basetypes.StringValue, was: %T`, ssoIdpCertAttribute))
	}

	ssoIdpSignAlgoAttribute, ok := attributes["sso_idp_sign_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_idp_sign_algo is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoIdpSignAlgoVal, ok := ssoIdpSignAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_idp_sign_algo expected to be basetypes.StringValue, was: %T`, ssoIdpSignAlgoAttribute))
	}

	ssoIdpSsoUrlAttribute, ok := attributes["sso_idp_sso_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_idp_sso_url is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoIdpSsoUrlVal, ok := ssoIdpSsoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_idp_sso_url expected to be basetypes.StringValue, was: %T`, ssoIdpSsoUrlAttribute))
	}

	ssoIssuerAttribute, ok := attributes["sso_issuer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_issuer is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoIssuerVal, ok := ssoIssuerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_issuer expected to be basetypes.StringValue, was: %T`, ssoIssuerAttribute))
	}

	ssoNameidFormatAttribute, ok := attributes["sso_nameid_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_nameid_format is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoNameidFormatVal, ok := ssoNameidFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_nameid_format expected to be basetypes.StringValue, was: %T`, ssoNameidFormatAttribute))
	}

	telstraClientIdAttribute, ok := attributes["telstra_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`telstra_client_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	telstraClientIdVal, ok := telstraClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`telstra_client_id expected to be basetypes.StringValue, was: %T`, telstraClientIdAttribute))
	}

	telstraClientSecretAttribute, ok := attributes["telstra_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`telstra_client_secret is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	telstraClientSecretVal, ok := telstraClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`telstra_client_secret expected to be basetypes.StringValue, was: %T`, telstraClientSecretAttribute))
	}

	twilioAuthTokenAttribute, ok := attributes["twilio_auth_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`twilio_auth_token is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	twilioAuthTokenVal, ok := twilioAuthTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`twilio_auth_token expected to be basetypes.StringValue, was: %T`, twilioAuthTokenAttribute))
	}

	twilioPhoneNumberAttribute, ok := attributes["twilio_phone_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`twilio_phone_number is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	twilioPhoneNumberVal, ok := twilioPhoneNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`twilio_phone_number expected to be basetypes.StringValue, was: %T`, twilioPhoneNumberAttribute))
	}

	twilioSidAttribute, ok := attributes["twilio_sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`twilio_sid is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	twilioSidVal, ok := twilioSidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`twilio_sid expected to be basetypes.StringValue, was: %T`, twilioSidAttribute))
	}

	if diags.HasError() {
		return NewPortalValueUnknown(), diags
	}

	return PortalValue{
		AmazonClientId:              amazonClientIdVal,
		AmazonClientSecret:          amazonClientSecretVal,
		AmazonEmailDomains:          amazonEmailDomainsVal,
		AmazonEnabled:               amazonEnabledVal,
		AmazonExpire:                amazonExpireVal,
		Auth:                        authVal,
		AzureClientId:               azureClientIdVal,
		AzureClientSecret:           azureClientSecretVal,
		AzureEnabled:                azureEnabledVal,
		AzureExpire:                 azureExpireVal,
		AzureTenantId:               azureTenantIdVal,
		BroadnetPassword:            broadnetPasswordVal,
		BroadnetSid:                 broadnetSidVal,
		BroadnetUserId:              broadnetUserIdVal,
		BypassWhenCloudDown:         bypassWhenCloudDownVal,
		ClickatellApiKey:            clickatellApiKeyVal,
		CrossSite:                   crossSiteVal,
		EmailEnabled:                emailEnabledVal,
		Enabled:                     enabledVal,
		Expire:                      expireVal,
		ExternalPortalUrl:           externalPortalUrlVal,
		FacebookClientId:            facebookClientIdVal,
		FacebookClientSecret:        facebookClientSecretVal,
		FacebookEmailDomains:        facebookEmailDomainsVal,
		FacebookEnabled:             facebookEnabledVal,
		FacebookExpire:              facebookExpireVal,
		Forward:                     forwardVal,
		ForwardUrl:                  forwardUrlVal,
		GoogleClientId:              googleClientIdVal,
		GoogleClientSecret:          googleClientSecretVal,
		GoogleEmailDomains:          googleEmailDomainsVal,
		GoogleEnabled:               googleEnabledVal,
		GoogleExpire:                googleExpireVal,
		GupshupPassword:             gupshupPasswordVal,
		GupshupUserid:               gupshupUseridVal,
		MicrosoftClientId:           microsoftClientIdVal,
		MicrosoftClientSecret:       microsoftClientSecretVal,
		MicrosoftEmailDomains:       microsoftEmailDomainsVal,
		MicrosoftEnabled:            microsoftEnabledVal,
		MicrosoftExpire:             microsoftExpireVal,
		PassphraseEnabled:           passphraseEnabledVal,
		PassphraseExpire:            passphraseExpireVal,
		Password:                    passwordVal,
		PortalApiSecret:             portalApiSecretVal,
		PortalImage:                 portalImageVal,
		PortalSsoUrl:                portalSsoUrlVal,
		PredefinedSponsorsEnabled:   predefinedSponsorsEnabledVal,
		Privacy:                     privacyVal,
		PuzzelPassword:              puzzelPasswordVal,
		PuzzelServiceId:             puzzelServiceIdVal,
		PuzzelUsername:              puzzelUsernameVal,
		SmsEnabled:                  smsEnabledVal,
		SmsExpire:                   smsExpireVal,
		SmsMessageFormat:            smsMessageFormatVal,
		SmsProvider:                 smsProviderVal,
		SponsorAutoApprove:          sponsorAutoApproveVal,
		SponsorEmailDomains:         sponsorEmailDomainsVal,
		SponsorEnabled:              sponsorEnabledVal,
		SponsorExpire:               sponsorExpireVal,
		SponsorLinkValidityDuration: sponsorLinkValidityDurationVal,
		SponsorNotifyAll:            sponsorNotifyAllVal,
		SponsorStatusNotify:         sponsorStatusNotifyVal,
		Sponsors:                    sponsorsVal,
		SsoDefaultRole:              ssoDefaultRoleVal,
		SsoForcedRole:               ssoForcedRoleVal,
		SsoIdpCert:                  ssoIdpCertVal,
		SsoIdpSignAlgo:              ssoIdpSignAlgoVal,
		SsoIdpSsoUrl:                ssoIdpSsoUrlVal,
		SsoIssuer:                   ssoIssuerVal,
		SsoNameidFormat:             ssoNameidFormatVal,
		TelstraClientId:             telstraClientIdVal,
		TelstraClientSecret:         telstraClientSecretVal,
		TwilioAuthToken:             twilioAuthTokenVal,
		TwilioPhoneNumber:           twilioPhoneNumberVal,
		TwilioSid:                   twilioSidVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewPortalValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortalValue {
	object, diags := NewPortalValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortalValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortalType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortalValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortalValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortalValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortalValueMust(PortalValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortalType) ValueType(ctx context.Context) attr.Value {
	return PortalValue{}
}

var _ basetypes.ObjectValuable = PortalValue{}

type PortalValue struct {
	AmazonClientId              basetypes.StringValue  `tfsdk:"amazon_client_id"`
	AmazonClientSecret          basetypes.StringValue  `tfsdk:"amazon_client_secret"`
	AmazonEmailDomains          basetypes.ListValue    `tfsdk:"amazon_email_domains"`
	AmazonEnabled               basetypes.BoolValue    `tfsdk:"amazon_enabled"`
	AmazonExpire                basetypes.Float64Value `tfsdk:"amazon_expire"`
	Auth                        basetypes.StringValue  `tfsdk:"auth"`
	AzureClientId               basetypes.StringValue  `tfsdk:"azure_client_id"`
	AzureClientSecret           basetypes.StringValue  `tfsdk:"azure_client_secret"`
	AzureEnabled                basetypes.BoolValue    `tfsdk:"azure_enabled"`
	AzureExpire                 basetypes.Float64Value `tfsdk:"azure_expire"`
	AzureTenantId               basetypes.StringValue  `tfsdk:"azure_tenant_id"`
	BroadnetPassword            basetypes.StringValue  `tfsdk:"broadnet_password"`
	BroadnetSid                 basetypes.StringValue  `tfsdk:"broadnet_sid"`
	BroadnetUserId              basetypes.StringValue  `tfsdk:"broadnet_user_id"`
	BypassWhenCloudDown         basetypes.BoolValue    `tfsdk:"bypass_when_cloud_down"`
	ClickatellApiKey            basetypes.StringValue  `tfsdk:"clickatell_api_key"`
	CrossSite                   basetypes.BoolValue    `tfsdk:"cross_site"`
	EmailEnabled                basetypes.BoolValue    `tfsdk:"email_enabled"`
	Enabled                     basetypes.BoolValue    `tfsdk:"enabled"`
	Expire                      basetypes.Float64Value `tfsdk:"expire"`
	ExternalPortalUrl           basetypes.StringValue  `tfsdk:"external_portal_url"`
	FacebookClientId            basetypes.StringValue  `tfsdk:"facebook_client_id"`
	FacebookClientSecret        basetypes.StringValue  `tfsdk:"facebook_client_secret"`
	FacebookEmailDomains        basetypes.ListValue    `tfsdk:"facebook_email_domains"`
	FacebookEnabled             basetypes.BoolValue    `tfsdk:"facebook_enabled"`
	FacebookExpire              basetypes.Float64Value `tfsdk:"facebook_expire"`
	Forward                     basetypes.BoolValue    `tfsdk:"forward"`
	ForwardUrl                  basetypes.StringValue  `tfsdk:"forward_url"`
	GoogleClientId              basetypes.StringValue  `tfsdk:"google_client_id"`
	GoogleClientSecret          basetypes.StringValue  `tfsdk:"google_client_secret"`
	GoogleEmailDomains          basetypes.ListValue    `tfsdk:"google_email_domains"`
	GoogleEnabled               basetypes.BoolValue    `tfsdk:"google_enabled"`
	GoogleExpire                basetypes.Float64Value `tfsdk:"google_expire"`
	GupshupPassword             basetypes.StringValue  `tfsdk:"gupshup_password"`
	GupshupUserid               basetypes.StringValue  `tfsdk:"gupshup_userid"`
	MicrosoftClientId           basetypes.StringValue  `tfsdk:"microsoft_client_id"`
	MicrosoftClientSecret       basetypes.StringValue  `tfsdk:"microsoft_client_secret"`
	MicrosoftEmailDomains       basetypes.ListValue    `tfsdk:"microsoft_email_domains"`
	MicrosoftEnabled            basetypes.BoolValue    `tfsdk:"microsoft_enabled"`
	MicrosoftExpire             basetypes.Float64Value `tfsdk:"microsoft_expire"`
	PassphraseEnabled           basetypes.BoolValue    `tfsdk:"passphrase_enabled"`
	PassphraseExpire            basetypes.Float64Value `tfsdk:"passphrase_expire"`
	Password                    basetypes.StringValue  `tfsdk:"password"`
	PortalApiSecret             basetypes.StringValue  `tfsdk:"portal_api_secret"`
	PortalImage                 basetypes.StringValue  `tfsdk:"portal_image"`
	PortalSsoUrl                basetypes.StringValue  `tfsdk:"portal_sso_url"`
	PredefinedSponsorsEnabled   basetypes.BoolValue    `tfsdk:"predefined_sponsors_enabled"`
	Privacy                     basetypes.BoolValue    `tfsdk:"privacy"`
	PuzzelPassword              basetypes.StringValue  `tfsdk:"puzzel_password"`
	PuzzelServiceId             basetypes.StringValue  `tfsdk:"puzzel_service_id"`
	PuzzelUsername              basetypes.StringValue  `tfsdk:"puzzel_username"`
	SmsEnabled                  basetypes.BoolValue    `tfsdk:"sms_enabled"`
	SmsExpire                   basetypes.Float64Value `tfsdk:"sms_expire"`
	SmsMessageFormat            basetypes.StringValue  `tfsdk:"sms_message_format"`
	SmsProvider                 basetypes.StringValue  `tfsdk:"sms_provider"`
	SponsorAutoApprove          basetypes.BoolValue    `tfsdk:"sponsor_auto_approve"`
	SponsorEmailDomains         basetypes.ListValue    `tfsdk:"sponsor_email_domains"`
	SponsorEnabled              basetypes.BoolValue    `tfsdk:"sponsor_enabled"`
	SponsorExpire               basetypes.Float64Value `tfsdk:"sponsor_expire"`
	SponsorLinkValidityDuration basetypes.Int64Value   `tfsdk:"sponsor_link_validity_duration"`
	SponsorNotifyAll            basetypes.BoolValue    `tfsdk:"sponsor_notify_all"`
	SponsorStatusNotify         basetypes.BoolValue    `tfsdk:"sponsor_status_notify"`
	Sponsors                    basetypes.MapValue     `tfsdk:"sponsors"`
	SsoDefaultRole              basetypes.StringValue  `tfsdk:"sso_default_role"`
	SsoForcedRole               basetypes.StringValue  `tfsdk:"sso_forced_role"`
	SsoIdpCert                  basetypes.StringValue  `tfsdk:"sso_idp_cert"`
	SsoIdpSignAlgo              basetypes.StringValue  `tfsdk:"sso_idp_sign_algo"`
	SsoIdpSsoUrl                basetypes.StringValue  `tfsdk:"sso_idp_sso_url"`
	SsoIssuer                   basetypes.StringValue  `tfsdk:"sso_issuer"`
	SsoNameidFormat             basetypes.StringValue  `tfsdk:"sso_nameid_format"`
	TelstraClientId             basetypes.StringValue  `tfsdk:"telstra_client_id"`
	TelstraClientSecret         basetypes.StringValue  `tfsdk:"telstra_client_secret"`
	TwilioAuthToken             basetypes.StringValue  `tfsdk:"twilio_auth_token"`
	TwilioPhoneNumber           basetypes.StringValue  `tfsdk:"twilio_phone_number"`
	TwilioSid                   basetypes.StringValue  `tfsdk:"twilio_sid"`
	state                       attr.ValueState
}

func (v PortalValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 75)

	var val tftypes.Value
	var err error

	attrTypes["amazon_client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["amazon_client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["amazon_email_domains"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["amazon_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["amazon_expire"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["azure_client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["azure_client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["azure_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["azure_expire"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["azure_tenant_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["broadnet_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["broadnet_sid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["broadnet_user_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bypass_when_cloud_down"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["clickatell_api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cross_site"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["email_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["expire"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["external_portal_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["facebook_client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["facebook_client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["facebook_email_domains"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["facebook_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["facebook_expire"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["forward"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["forward_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["google_client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["google_client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["google_email_domains"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["google_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["google_expire"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["gupshup_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gupshup_userid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["microsoft_client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["microsoft_client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["microsoft_email_domains"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["microsoft_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["microsoft_expire"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["passphrase_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["passphrase_expire"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["portal_api_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["portal_image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["portal_sso_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["predefined_sponsors_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["privacy"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["puzzel_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["puzzel_service_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["puzzel_username"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sms_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sms_expire"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["sms_message_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sms_provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sponsor_auto_approve"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sponsor_email_domains"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["sponsor_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sponsor_expire"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["sponsor_link_validity_duration"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["sponsor_notify_all"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sponsor_status_notify"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sponsors"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["sso_default_role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sso_forced_role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sso_idp_cert"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sso_idp_sign_algo"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sso_idp_sso_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sso_issuer"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sso_nameid_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["telstra_client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["telstra_client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["twilio_auth_token"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["twilio_phone_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["twilio_sid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 75)

		val, err = v.AmazonClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amazon_client_id"] = val

		val, err = v.AmazonClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amazon_client_secret"] = val

		val, err = v.AmazonEmailDomains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amazon_email_domains"] = val

		val, err = v.AmazonEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amazon_enabled"] = val

		val, err = v.AmazonExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amazon_expire"] = val

		val, err = v.Auth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth"] = val

		val, err = v.AzureClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["azure_client_id"] = val

		val, err = v.AzureClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["azure_client_secret"] = val

		val, err = v.AzureEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["azure_enabled"] = val

		val, err = v.AzureExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["azure_expire"] = val

		val, err = v.AzureTenantId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["azure_tenant_id"] = val

		val, err = v.BroadnetPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["broadnet_password"] = val

		val, err = v.BroadnetSid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["broadnet_sid"] = val

		val, err = v.BroadnetUserId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["broadnet_user_id"] = val

		val, err = v.BypassWhenCloudDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bypass_when_cloud_down"] = val

		val, err = v.ClickatellApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["clickatell_api_key"] = val

		val, err = v.CrossSite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cross_site"] = val

		val, err = v.EmailEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email_enabled"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Expire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["expire"] = val

		val, err = v.ExternalPortalUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_portal_url"] = val

		val, err = v.FacebookClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facebook_client_id"] = val

		val, err = v.FacebookClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facebook_client_secret"] = val

		val, err = v.FacebookEmailDomains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facebook_email_domains"] = val

		val, err = v.FacebookEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facebook_enabled"] = val

		val, err = v.FacebookExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facebook_expire"] = val

		val, err = v.Forward.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forward"] = val

		val, err = v.ForwardUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forward_url"] = val

		val, err = v.GoogleClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["google_client_id"] = val

		val, err = v.GoogleClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["google_client_secret"] = val

		val, err = v.GoogleEmailDomains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["google_email_domains"] = val

		val, err = v.GoogleEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["google_enabled"] = val

		val, err = v.GoogleExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["google_expire"] = val

		val, err = v.GupshupPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gupshup_password"] = val

		val, err = v.GupshupUserid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gupshup_userid"] = val

		val, err = v.MicrosoftClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["microsoft_client_id"] = val

		val, err = v.MicrosoftClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["microsoft_client_secret"] = val

		val, err = v.MicrosoftEmailDomains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["microsoft_email_domains"] = val

		val, err = v.MicrosoftEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["microsoft_enabled"] = val

		val, err = v.MicrosoftExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["microsoft_expire"] = val

		val, err = v.PassphraseEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["passphrase_enabled"] = val

		val, err = v.PassphraseExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["passphrase_expire"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.PortalApiSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["portal_api_secret"] = val

		val, err = v.PortalImage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["portal_image"] = val

		val, err = v.PortalSsoUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["portal_sso_url"] = val

		val, err = v.PredefinedSponsorsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["predefined_sponsors_enabled"] = val

		val, err = v.Privacy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["privacy"] = val

		val, err = v.PuzzelPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["puzzel_password"] = val

		val, err = v.PuzzelServiceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["puzzel_service_id"] = val

		val, err = v.PuzzelUsername.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["puzzel_username"] = val

		val, err = v.SmsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sms_enabled"] = val

		val, err = v.SmsExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sms_expire"] = val

		val, err = v.SmsMessageFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sms_message_format"] = val

		val, err = v.SmsProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sms_provider"] = val

		val, err = v.SponsorAutoApprove.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_auto_approve"] = val

		val, err = v.SponsorEmailDomains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_email_domains"] = val

		val, err = v.SponsorEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_enabled"] = val

		val, err = v.SponsorExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_expire"] = val

		val, err = v.SponsorLinkValidityDuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_link_validity_duration"] = val

		val, err = v.SponsorNotifyAll.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_notify_all"] = val

		val, err = v.SponsorStatusNotify.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_status_notify"] = val

		val, err = v.Sponsors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsors"] = val

		val, err = v.SsoDefaultRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_default_role"] = val

		val, err = v.SsoForcedRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_forced_role"] = val

		val, err = v.SsoIdpCert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_idp_cert"] = val

		val, err = v.SsoIdpSignAlgo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_idp_sign_algo"] = val

		val, err = v.SsoIdpSsoUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_idp_sso_url"] = val

		val, err = v.SsoIssuer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_issuer"] = val

		val, err = v.SsoNameidFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_nameid_format"] = val

		val, err = v.TelstraClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["telstra_client_id"] = val

		val, err = v.TelstraClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["telstra_client_secret"] = val

		val, err = v.TwilioAuthToken.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["twilio_auth_token"] = val

		val, err = v.TwilioPhoneNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["twilio_phone_number"] = val

		val, err = v.TwilioSid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["twilio_sid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortalValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortalValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortalValue) String() string {
	return "PortalValue"
}

func (v PortalValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	amazonEmailDomainsVal, d := types.ListValue(types.StringType, v.AmazonEmailDomains.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amazon_client_id":     basetypes.StringType{},
			"amazon_client_secret": basetypes.StringType{},
			"amazon_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"amazon_enabled":         basetypes.BoolType{},
			"amazon_expire":          basetypes.Float64Type{},
			"auth":                   basetypes.StringType{},
			"azure_client_id":        basetypes.StringType{},
			"azure_client_secret":    basetypes.StringType{},
			"azure_enabled":          basetypes.BoolType{},
			"azure_expire":           basetypes.Float64Type{},
			"azure_tenant_id":        basetypes.StringType{},
			"broadnet_password":      basetypes.StringType{},
			"broadnet_sid":           basetypes.StringType{},
			"broadnet_user_id":       basetypes.StringType{},
			"bypass_when_cloud_down": basetypes.BoolType{},
			"clickatell_api_key":     basetypes.StringType{},
			"cross_site":             basetypes.BoolType{},
			"email_enabled":          basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"expire":                 basetypes.Float64Type{},
			"external_portal_url":    basetypes.StringType{},
			"facebook_client_id":     basetypes.StringType{},
			"facebook_client_secret": basetypes.StringType{},
			"facebook_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"facebook_enabled":     basetypes.BoolType{},
			"facebook_expire":      basetypes.Float64Type{},
			"forward":              basetypes.BoolType{},
			"forward_url":          basetypes.StringType{},
			"google_client_id":     basetypes.StringType{},
			"google_client_secret": basetypes.StringType{},
			"google_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"google_enabled":          basetypes.BoolType{},
			"google_expire":           basetypes.Float64Type{},
			"gupshup_password":        basetypes.StringType{},
			"gupshup_userid":          basetypes.StringType{},
			"microsoft_client_id":     basetypes.StringType{},
			"microsoft_client_secret": basetypes.StringType{},
			"microsoft_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"microsoft_enabled":           basetypes.BoolType{},
			"microsoft_expire":            basetypes.Float64Type{},
			"passphrase_enabled":          basetypes.BoolType{},
			"passphrase_expire":           basetypes.Float64Type{},
			"password":                    basetypes.StringType{},
			"portal_api_secret":           basetypes.StringType{},
			"portal_image":                basetypes.StringType{},
			"portal_sso_url":              basetypes.StringType{},
			"predefined_sponsors_enabled": basetypes.BoolType{},
			"privacy":                     basetypes.BoolType{},
			"puzzel_password":             basetypes.StringType{},
			"puzzel_service_id":           basetypes.StringType{},
			"puzzel_username":             basetypes.StringType{},
			"sms_enabled":                 basetypes.BoolType{},
			"sms_expire":                  basetypes.Float64Type{},
			"sms_message_format":          basetypes.StringType{},
			"sms_provider":                basetypes.StringType{},
			"sponsor_auto_approve":        basetypes.BoolType{},
			"sponsor_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sponsor_enabled":                basetypes.BoolType{},
			"sponsor_expire":                 basetypes.Float64Type{},
			"sponsor_link_validity_duration": basetypes.Int64Type{},
			"sponsor_notify_all":             basetypes.BoolType{},
			"sponsor_status_notify":          basetypes.BoolType{},
			"sponsors": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sso_default_role":      basetypes.StringType{},
			"sso_forced_role":       basetypes.StringType{},
			"sso_idp_cert":          basetypes.StringType{},
			"sso_idp_sign_algo":     basetypes.StringType{},
			"sso_idp_sso_url":       basetypes.StringType{},
			"sso_issuer":            basetypes.StringType{},
			"sso_nameid_format":     basetypes.StringType{},
			"telstra_client_id":     basetypes.StringType{},
			"telstra_client_secret": basetypes.StringType{},
			"twilio_auth_token":     basetypes.StringType{},
			"twilio_phone_number":   basetypes.StringType{},
			"twilio_sid":            basetypes.StringType{},
		}), diags
	}

	facebookEmailDomainsVal, d := types.ListValue(types.StringType, v.FacebookEmailDomains.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amazon_client_id":     basetypes.StringType{},
			"amazon_client_secret": basetypes.StringType{},
			"amazon_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"amazon_enabled":         basetypes.BoolType{},
			"amazon_expire":          basetypes.Float64Type{},
			"auth":                   basetypes.StringType{},
			"azure_client_id":        basetypes.StringType{},
			"azure_client_secret":    basetypes.StringType{},
			"azure_enabled":          basetypes.BoolType{},
			"azure_expire":           basetypes.Float64Type{},
			"azure_tenant_id":        basetypes.StringType{},
			"broadnet_password":      basetypes.StringType{},
			"broadnet_sid":           basetypes.StringType{},
			"broadnet_user_id":       basetypes.StringType{},
			"bypass_when_cloud_down": basetypes.BoolType{},
			"clickatell_api_key":     basetypes.StringType{},
			"cross_site":             basetypes.BoolType{},
			"email_enabled":          basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"expire":                 basetypes.Float64Type{},
			"external_portal_url":    basetypes.StringType{},
			"facebook_client_id":     basetypes.StringType{},
			"facebook_client_secret": basetypes.StringType{},
			"facebook_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"facebook_enabled":     basetypes.BoolType{},
			"facebook_expire":      basetypes.Float64Type{},
			"forward":              basetypes.BoolType{},
			"forward_url":          basetypes.StringType{},
			"google_client_id":     basetypes.StringType{},
			"google_client_secret": basetypes.StringType{},
			"google_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"google_enabled":          basetypes.BoolType{},
			"google_expire":           basetypes.Float64Type{},
			"gupshup_password":        basetypes.StringType{},
			"gupshup_userid":          basetypes.StringType{},
			"microsoft_client_id":     basetypes.StringType{},
			"microsoft_client_secret": basetypes.StringType{},
			"microsoft_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"microsoft_enabled":           basetypes.BoolType{},
			"microsoft_expire":            basetypes.Float64Type{},
			"passphrase_enabled":          basetypes.BoolType{},
			"passphrase_expire":           basetypes.Float64Type{},
			"password":                    basetypes.StringType{},
			"portal_api_secret":           basetypes.StringType{},
			"portal_image":                basetypes.StringType{},
			"portal_sso_url":              basetypes.StringType{},
			"predefined_sponsors_enabled": basetypes.BoolType{},
			"privacy":                     basetypes.BoolType{},
			"puzzel_password":             basetypes.StringType{},
			"puzzel_service_id":           basetypes.StringType{},
			"puzzel_username":             basetypes.StringType{},
			"sms_enabled":                 basetypes.BoolType{},
			"sms_expire":                  basetypes.Float64Type{},
			"sms_message_format":          basetypes.StringType{},
			"sms_provider":                basetypes.StringType{},
			"sponsor_auto_approve":        basetypes.BoolType{},
			"sponsor_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sponsor_enabled":                basetypes.BoolType{},
			"sponsor_expire":                 basetypes.Float64Type{},
			"sponsor_link_validity_duration": basetypes.Int64Type{},
			"sponsor_notify_all":             basetypes.BoolType{},
			"sponsor_status_notify":          basetypes.BoolType{},
			"sponsors": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sso_default_role":      basetypes.StringType{},
			"sso_forced_role":       basetypes.StringType{},
			"sso_idp_cert":          basetypes.StringType{},
			"sso_idp_sign_algo":     basetypes.StringType{},
			"sso_idp_sso_url":       basetypes.StringType{},
			"sso_issuer":            basetypes.StringType{},
			"sso_nameid_format":     basetypes.StringType{},
			"telstra_client_id":     basetypes.StringType{},
			"telstra_client_secret": basetypes.StringType{},
			"twilio_auth_token":     basetypes.StringType{},
			"twilio_phone_number":   basetypes.StringType{},
			"twilio_sid":            basetypes.StringType{},
		}), diags
	}

	googleEmailDomainsVal, d := types.ListValue(types.StringType, v.GoogleEmailDomains.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amazon_client_id":     basetypes.StringType{},
			"amazon_client_secret": basetypes.StringType{},
			"amazon_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"amazon_enabled":         basetypes.BoolType{},
			"amazon_expire":          basetypes.Float64Type{},
			"auth":                   basetypes.StringType{},
			"azure_client_id":        basetypes.StringType{},
			"azure_client_secret":    basetypes.StringType{},
			"azure_enabled":          basetypes.BoolType{},
			"azure_expire":           basetypes.Float64Type{},
			"azure_tenant_id":        basetypes.StringType{},
			"broadnet_password":      basetypes.StringType{},
			"broadnet_sid":           basetypes.StringType{},
			"broadnet_user_id":       basetypes.StringType{},
			"bypass_when_cloud_down": basetypes.BoolType{},
			"clickatell_api_key":     basetypes.StringType{},
			"cross_site":             basetypes.BoolType{},
			"email_enabled":          basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"expire":                 basetypes.Float64Type{},
			"external_portal_url":    basetypes.StringType{},
			"facebook_client_id":     basetypes.StringType{},
			"facebook_client_secret": basetypes.StringType{},
			"facebook_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"facebook_enabled":     basetypes.BoolType{},
			"facebook_expire":      basetypes.Float64Type{},
			"forward":              basetypes.BoolType{},
			"forward_url":          basetypes.StringType{},
			"google_client_id":     basetypes.StringType{},
			"google_client_secret": basetypes.StringType{},
			"google_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"google_enabled":          basetypes.BoolType{},
			"google_expire":           basetypes.Float64Type{},
			"gupshup_password":        basetypes.StringType{},
			"gupshup_userid":          basetypes.StringType{},
			"microsoft_client_id":     basetypes.StringType{},
			"microsoft_client_secret": basetypes.StringType{},
			"microsoft_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"microsoft_enabled":           basetypes.BoolType{},
			"microsoft_expire":            basetypes.Float64Type{},
			"passphrase_enabled":          basetypes.BoolType{},
			"passphrase_expire":           basetypes.Float64Type{},
			"password":                    basetypes.StringType{},
			"portal_api_secret":           basetypes.StringType{},
			"portal_image":                basetypes.StringType{},
			"portal_sso_url":              basetypes.StringType{},
			"predefined_sponsors_enabled": basetypes.BoolType{},
			"privacy":                     basetypes.BoolType{},
			"puzzel_password":             basetypes.StringType{},
			"puzzel_service_id":           basetypes.StringType{},
			"puzzel_username":             basetypes.StringType{},
			"sms_enabled":                 basetypes.BoolType{},
			"sms_expire":                  basetypes.Float64Type{},
			"sms_message_format":          basetypes.StringType{},
			"sms_provider":                basetypes.StringType{},
			"sponsor_auto_approve":        basetypes.BoolType{},
			"sponsor_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sponsor_enabled":                basetypes.BoolType{},
			"sponsor_expire":                 basetypes.Float64Type{},
			"sponsor_link_validity_duration": basetypes.Int64Type{},
			"sponsor_notify_all":             basetypes.BoolType{},
			"sponsor_status_notify":          basetypes.BoolType{},
			"sponsors": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sso_default_role":      basetypes.StringType{},
			"sso_forced_role":       basetypes.StringType{},
			"sso_idp_cert":          basetypes.StringType{},
			"sso_idp_sign_algo":     basetypes.StringType{},
			"sso_idp_sso_url":       basetypes.StringType{},
			"sso_issuer":            basetypes.StringType{},
			"sso_nameid_format":     basetypes.StringType{},
			"telstra_client_id":     basetypes.StringType{},
			"telstra_client_secret": basetypes.StringType{},
			"twilio_auth_token":     basetypes.StringType{},
			"twilio_phone_number":   basetypes.StringType{},
			"twilio_sid":            basetypes.StringType{},
		}), diags
	}

	microsoftEmailDomainsVal, d := types.ListValue(types.StringType, v.MicrosoftEmailDomains.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amazon_client_id":     basetypes.StringType{},
			"amazon_client_secret": basetypes.StringType{},
			"amazon_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"amazon_enabled":         basetypes.BoolType{},
			"amazon_expire":          basetypes.Float64Type{},
			"auth":                   basetypes.StringType{},
			"azure_client_id":        basetypes.StringType{},
			"azure_client_secret":    basetypes.StringType{},
			"azure_enabled":          basetypes.BoolType{},
			"azure_expire":           basetypes.Float64Type{},
			"azure_tenant_id":        basetypes.StringType{},
			"broadnet_password":      basetypes.StringType{},
			"broadnet_sid":           basetypes.StringType{},
			"broadnet_user_id":       basetypes.StringType{},
			"bypass_when_cloud_down": basetypes.BoolType{},
			"clickatell_api_key":     basetypes.StringType{},
			"cross_site":             basetypes.BoolType{},
			"email_enabled":          basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"expire":                 basetypes.Float64Type{},
			"external_portal_url":    basetypes.StringType{},
			"facebook_client_id":     basetypes.StringType{},
			"facebook_client_secret": basetypes.StringType{},
			"facebook_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"facebook_enabled":     basetypes.BoolType{},
			"facebook_expire":      basetypes.Float64Type{},
			"forward":              basetypes.BoolType{},
			"forward_url":          basetypes.StringType{},
			"google_client_id":     basetypes.StringType{},
			"google_client_secret": basetypes.StringType{},
			"google_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"google_enabled":          basetypes.BoolType{},
			"google_expire":           basetypes.Float64Type{},
			"gupshup_password":        basetypes.StringType{},
			"gupshup_userid":          basetypes.StringType{},
			"microsoft_client_id":     basetypes.StringType{},
			"microsoft_client_secret": basetypes.StringType{},
			"microsoft_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"microsoft_enabled":           basetypes.BoolType{},
			"microsoft_expire":            basetypes.Float64Type{},
			"passphrase_enabled":          basetypes.BoolType{},
			"passphrase_expire":           basetypes.Float64Type{},
			"password":                    basetypes.StringType{},
			"portal_api_secret":           basetypes.StringType{},
			"portal_image":                basetypes.StringType{},
			"portal_sso_url":              basetypes.StringType{},
			"predefined_sponsors_enabled": basetypes.BoolType{},
			"privacy":                     basetypes.BoolType{},
			"puzzel_password":             basetypes.StringType{},
			"puzzel_service_id":           basetypes.StringType{},
			"puzzel_username":             basetypes.StringType{},
			"sms_enabled":                 basetypes.BoolType{},
			"sms_expire":                  basetypes.Float64Type{},
			"sms_message_format":          basetypes.StringType{},
			"sms_provider":                basetypes.StringType{},
			"sponsor_auto_approve":        basetypes.BoolType{},
			"sponsor_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sponsor_enabled":                basetypes.BoolType{},
			"sponsor_expire":                 basetypes.Float64Type{},
			"sponsor_link_validity_duration": basetypes.Int64Type{},
			"sponsor_notify_all":             basetypes.BoolType{},
			"sponsor_status_notify":          basetypes.BoolType{},
			"sponsors": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sso_default_role":      basetypes.StringType{},
			"sso_forced_role":       basetypes.StringType{},
			"sso_idp_cert":          basetypes.StringType{},
			"sso_idp_sign_algo":     basetypes.StringType{},
			"sso_idp_sso_url":       basetypes.StringType{},
			"sso_issuer":            basetypes.StringType{},
			"sso_nameid_format":     basetypes.StringType{},
			"telstra_client_id":     basetypes.StringType{},
			"telstra_client_secret": basetypes.StringType{},
			"twilio_auth_token":     basetypes.StringType{},
			"twilio_phone_number":   basetypes.StringType{},
			"twilio_sid":            basetypes.StringType{},
		}), diags
	}

	sponsorEmailDomainsVal, d := types.ListValue(types.StringType, v.SponsorEmailDomains.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amazon_client_id":     basetypes.StringType{},
			"amazon_client_secret": basetypes.StringType{},
			"amazon_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"amazon_enabled":         basetypes.BoolType{},
			"amazon_expire":          basetypes.Float64Type{},
			"auth":                   basetypes.StringType{},
			"azure_client_id":        basetypes.StringType{},
			"azure_client_secret":    basetypes.StringType{},
			"azure_enabled":          basetypes.BoolType{},
			"azure_expire":           basetypes.Float64Type{},
			"azure_tenant_id":        basetypes.StringType{},
			"broadnet_password":      basetypes.StringType{},
			"broadnet_sid":           basetypes.StringType{},
			"broadnet_user_id":       basetypes.StringType{},
			"bypass_when_cloud_down": basetypes.BoolType{},
			"clickatell_api_key":     basetypes.StringType{},
			"cross_site":             basetypes.BoolType{},
			"email_enabled":          basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"expire":                 basetypes.Float64Type{},
			"external_portal_url":    basetypes.StringType{},
			"facebook_client_id":     basetypes.StringType{},
			"facebook_client_secret": basetypes.StringType{},
			"facebook_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"facebook_enabled":     basetypes.BoolType{},
			"facebook_expire":      basetypes.Float64Type{},
			"forward":              basetypes.BoolType{},
			"forward_url":          basetypes.StringType{},
			"google_client_id":     basetypes.StringType{},
			"google_client_secret": basetypes.StringType{},
			"google_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"google_enabled":          basetypes.BoolType{},
			"google_expire":           basetypes.Float64Type{},
			"gupshup_password":        basetypes.StringType{},
			"gupshup_userid":          basetypes.StringType{},
			"microsoft_client_id":     basetypes.StringType{},
			"microsoft_client_secret": basetypes.StringType{},
			"microsoft_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"microsoft_enabled":           basetypes.BoolType{},
			"microsoft_expire":            basetypes.Float64Type{},
			"passphrase_enabled":          basetypes.BoolType{},
			"passphrase_expire":           basetypes.Float64Type{},
			"password":                    basetypes.StringType{},
			"portal_api_secret":           basetypes.StringType{},
			"portal_image":                basetypes.StringType{},
			"portal_sso_url":              basetypes.StringType{},
			"predefined_sponsors_enabled": basetypes.BoolType{},
			"privacy":                     basetypes.BoolType{},
			"puzzel_password":             basetypes.StringType{},
			"puzzel_service_id":           basetypes.StringType{},
			"puzzel_username":             basetypes.StringType{},
			"sms_enabled":                 basetypes.BoolType{},
			"sms_expire":                  basetypes.Float64Type{},
			"sms_message_format":          basetypes.StringType{},
			"sms_provider":                basetypes.StringType{},
			"sponsor_auto_approve":        basetypes.BoolType{},
			"sponsor_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sponsor_enabled":                basetypes.BoolType{},
			"sponsor_expire":                 basetypes.Float64Type{},
			"sponsor_link_validity_duration": basetypes.Int64Type{},
			"sponsor_notify_all":             basetypes.BoolType{},
			"sponsor_status_notify":          basetypes.BoolType{},
			"sponsors": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sso_default_role":      basetypes.StringType{},
			"sso_forced_role":       basetypes.StringType{},
			"sso_idp_cert":          basetypes.StringType{},
			"sso_idp_sign_algo":     basetypes.StringType{},
			"sso_idp_sso_url":       basetypes.StringType{},
			"sso_issuer":            basetypes.StringType{},
			"sso_nameid_format":     basetypes.StringType{},
			"telstra_client_id":     basetypes.StringType{},
			"telstra_client_secret": basetypes.StringType{},
			"twilio_auth_token":     basetypes.StringType{},
			"twilio_phone_number":   basetypes.StringType{},
			"twilio_sid":            basetypes.StringType{},
		}), diags
	}

	sponsorsVal, d := types.MapValue(types.StringType, v.Sponsors.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amazon_client_id":     basetypes.StringType{},
			"amazon_client_secret": basetypes.StringType{},
			"amazon_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"amazon_enabled":         basetypes.BoolType{},
			"amazon_expire":          basetypes.Float64Type{},
			"auth":                   basetypes.StringType{},
			"azure_client_id":        basetypes.StringType{},
			"azure_client_secret":    basetypes.StringType{},
			"azure_enabled":          basetypes.BoolType{},
			"azure_expire":           basetypes.Float64Type{},
			"azure_tenant_id":        basetypes.StringType{},
			"broadnet_password":      basetypes.StringType{},
			"broadnet_sid":           basetypes.StringType{},
			"broadnet_user_id":       basetypes.StringType{},
			"bypass_when_cloud_down": basetypes.BoolType{},
			"clickatell_api_key":     basetypes.StringType{},
			"cross_site":             basetypes.BoolType{},
			"email_enabled":          basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"expire":                 basetypes.Float64Type{},
			"external_portal_url":    basetypes.StringType{},
			"facebook_client_id":     basetypes.StringType{},
			"facebook_client_secret": basetypes.StringType{},
			"facebook_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"facebook_enabled":     basetypes.BoolType{},
			"facebook_expire":      basetypes.Float64Type{},
			"forward":              basetypes.BoolType{},
			"forward_url":          basetypes.StringType{},
			"google_client_id":     basetypes.StringType{},
			"google_client_secret": basetypes.StringType{},
			"google_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"google_enabled":          basetypes.BoolType{},
			"google_expire":           basetypes.Float64Type{},
			"gupshup_password":        basetypes.StringType{},
			"gupshup_userid":          basetypes.StringType{},
			"microsoft_client_id":     basetypes.StringType{},
			"microsoft_client_secret": basetypes.StringType{},
			"microsoft_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"microsoft_enabled":           basetypes.BoolType{},
			"microsoft_expire":            basetypes.Float64Type{},
			"passphrase_enabled":          basetypes.BoolType{},
			"passphrase_expire":           basetypes.Float64Type{},
			"password":                    basetypes.StringType{},
			"portal_api_secret":           basetypes.StringType{},
			"portal_image":                basetypes.StringType{},
			"portal_sso_url":              basetypes.StringType{},
			"predefined_sponsors_enabled": basetypes.BoolType{},
			"privacy":                     basetypes.BoolType{},
			"puzzel_password":             basetypes.StringType{},
			"puzzel_service_id":           basetypes.StringType{},
			"puzzel_username":             basetypes.StringType{},
			"sms_enabled":                 basetypes.BoolType{},
			"sms_expire":                  basetypes.Float64Type{},
			"sms_message_format":          basetypes.StringType{},
			"sms_provider":                basetypes.StringType{},
			"sponsor_auto_approve":        basetypes.BoolType{},
			"sponsor_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sponsor_enabled":                basetypes.BoolType{},
			"sponsor_expire":                 basetypes.Float64Type{},
			"sponsor_link_validity_duration": basetypes.Int64Type{},
			"sponsor_notify_all":             basetypes.BoolType{},
			"sponsor_status_notify":          basetypes.BoolType{},
			"sponsors": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sso_default_role":      basetypes.StringType{},
			"sso_forced_role":       basetypes.StringType{},
			"sso_idp_cert":          basetypes.StringType{},
			"sso_idp_sign_algo":     basetypes.StringType{},
			"sso_idp_sso_url":       basetypes.StringType{},
			"sso_issuer":            basetypes.StringType{},
			"sso_nameid_format":     basetypes.StringType{},
			"telstra_client_id":     basetypes.StringType{},
			"telstra_client_secret": basetypes.StringType{},
			"twilio_auth_token":     basetypes.StringType{},
			"twilio_phone_number":   basetypes.StringType{},
			"twilio_sid":            basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amazon_client_id":     basetypes.StringType{},
		"amazon_client_secret": basetypes.StringType{},
		"amazon_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"amazon_enabled":         basetypes.BoolType{},
		"amazon_expire":          basetypes.Float64Type{},
		"auth":                   basetypes.StringType{},
		"azure_client_id":        basetypes.StringType{},
		"azure_client_secret":    basetypes.StringType{},
		"azure_enabled":          basetypes.BoolType{},
		"azure_expire":           basetypes.Float64Type{},
		"azure_tenant_id":        basetypes.StringType{},
		"broadnet_password":      basetypes.StringType{},
		"broadnet_sid":           basetypes.StringType{},
		"broadnet_user_id":       basetypes.StringType{},
		"bypass_when_cloud_down": basetypes.BoolType{},
		"clickatell_api_key":     basetypes.StringType{},
		"cross_site":             basetypes.BoolType{},
		"email_enabled":          basetypes.BoolType{},
		"enabled":                basetypes.BoolType{},
		"expire":                 basetypes.Float64Type{},
		"external_portal_url":    basetypes.StringType{},
		"facebook_client_id":     basetypes.StringType{},
		"facebook_client_secret": basetypes.StringType{},
		"facebook_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"facebook_enabled":     basetypes.BoolType{},
		"facebook_expire":      basetypes.Float64Type{},
		"forward":              basetypes.BoolType{},
		"forward_url":          basetypes.StringType{},
		"google_client_id":     basetypes.StringType{},
		"google_client_secret": basetypes.StringType{},
		"google_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"google_enabled":          basetypes.BoolType{},
		"google_expire":           basetypes.Float64Type{},
		"gupshup_password":        basetypes.StringType{},
		"gupshup_userid":          basetypes.StringType{},
		"microsoft_client_id":     basetypes.StringType{},
		"microsoft_client_secret": basetypes.StringType{},
		"microsoft_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"microsoft_enabled":           basetypes.BoolType{},
		"microsoft_expire":            basetypes.Float64Type{},
		"passphrase_enabled":          basetypes.BoolType{},
		"passphrase_expire":           basetypes.Float64Type{},
		"password":                    basetypes.StringType{},
		"portal_api_secret":           basetypes.StringType{},
		"portal_image":                basetypes.StringType{},
		"portal_sso_url":              basetypes.StringType{},
		"predefined_sponsors_enabled": basetypes.BoolType{},
		"privacy":                     basetypes.BoolType{},
		"puzzel_password":             basetypes.StringType{},
		"puzzel_service_id":           basetypes.StringType{},
		"puzzel_username":             basetypes.StringType{},
		"sms_enabled":                 basetypes.BoolType{},
		"sms_expire":                  basetypes.Float64Type{},
		"sms_message_format":          basetypes.StringType{},
		"sms_provider":                basetypes.StringType{},
		"sponsor_auto_approve":        basetypes.BoolType{},
		"sponsor_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"sponsor_enabled":                basetypes.BoolType{},
		"sponsor_expire":                 basetypes.Float64Type{},
		"sponsor_link_validity_duration": basetypes.Int64Type{},
		"sponsor_notify_all":             basetypes.BoolType{},
		"sponsor_status_notify":          basetypes.BoolType{},
		"sponsors": basetypes.MapType{
			ElemType: types.StringType,
		},
		"sso_default_role":      basetypes.StringType{},
		"sso_forced_role":       basetypes.StringType{},
		"sso_idp_cert":          basetypes.StringType{},
		"sso_idp_sign_algo":     basetypes.StringType{},
		"sso_idp_sso_url":       basetypes.StringType{},
		"sso_issuer":            basetypes.StringType{},
		"sso_nameid_format":     basetypes.StringType{},
		"telstra_client_id":     basetypes.StringType{},
		"telstra_client_secret": basetypes.StringType{},
		"twilio_auth_token":     basetypes.StringType{},
		"twilio_phone_number":   basetypes.StringType{},
		"twilio_sid":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amazon_client_id":               v.AmazonClientId,
			"amazon_client_secret":           v.AmazonClientSecret,
			"amazon_email_domains":           amazonEmailDomainsVal,
			"amazon_enabled":                 v.AmazonEnabled,
			"amazon_expire":                  v.AmazonExpire,
			"auth":                           v.Auth,
			"azure_client_id":                v.AzureClientId,
			"azure_client_secret":            v.AzureClientSecret,
			"azure_enabled":                  v.AzureEnabled,
			"azure_expire":                   v.AzureExpire,
			"azure_tenant_id":                v.AzureTenantId,
			"broadnet_password":              v.BroadnetPassword,
			"broadnet_sid":                   v.BroadnetSid,
			"broadnet_user_id":               v.BroadnetUserId,
			"bypass_when_cloud_down":         v.BypassWhenCloudDown,
			"clickatell_api_key":             v.ClickatellApiKey,
			"cross_site":                     v.CrossSite,
			"email_enabled":                  v.EmailEnabled,
			"enabled":                        v.Enabled,
			"expire":                         v.Expire,
			"external_portal_url":            v.ExternalPortalUrl,
			"facebook_client_id":             v.FacebookClientId,
			"facebook_client_secret":         v.FacebookClientSecret,
			"facebook_email_domains":         facebookEmailDomainsVal,
			"facebook_enabled":               v.FacebookEnabled,
			"facebook_expire":                v.FacebookExpire,
			"forward":                        v.Forward,
			"forward_url":                    v.ForwardUrl,
			"google_client_id":               v.GoogleClientId,
			"google_client_secret":           v.GoogleClientSecret,
			"google_email_domains":           googleEmailDomainsVal,
			"google_enabled":                 v.GoogleEnabled,
			"google_expire":                  v.GoogleExpire,
			"gupshup_password":               v.GupshupPassword,
			"gupshup_userid":                 v.GupshupUserid,
			"microsoft_client_id":            v.MicrosoftClientId,
			"microsoft_client_secret":        v.MicrosoftClientSecret,
			"microsoft_email_domains":        microsoftEmailDomainsVal,
			"microsoft_enabled":              v.MicrosoftEnabled,
			"microsoft_expire":               v.MicrosoftExpire,
			"passphrase_enabled":             v.PassphraseEnabled,
			"passphrase_expire":              v.PassphraseExpire,
			"password":                       v.Password,
			"portal_api_secret":              v.PortalApiSecret,
			"portal_image":                   v.PortalImage,
			"portal_sso_url":                 v.PortalSsoUrl,
			"predefined_sponsors_enabled":    v.PredefinedSponsorsEnabled,
			"privacy":                        v.Privacy,
			"puzzel_password":                v.PuzzelPassword,
			"puzzel_service_id":              v.PuzzelServiceId,
			"puzzel_username":                v.PuzzelUsername,
			"sms_enabled":                    v.SmsEnabled,
			"sms_expire":                     v.SmsExpire,
			"sms_message_format":             v.SmsMessageFormat,
			"sms_provider":                   v.SmsProvider,
			"sponsor_auto_approve":           v.SponsorAutoApprove,
			"sponsor_email_domains":          sponsorEmailDomainsVal,
			"sponsor_enabled":                v.SponsorEnabled,
			"sponsor_expire":                 v.SponsorExpire,
			"sponsor_link_validity_duration": v.SponsorLinkValidityDuration,
			"sponsor_notify_all":             v.SponsorNotifyAll,
			"sponsor_status_notify":          v.SponsorStatusNotify,
			"sponsors":                       sponsorsVal,
			"sso_default_role":               v.SsoDefaultRole,
			"sso_forced_role":                v.SsoForcedRole,
			"sso_idp_cert":                   v.SsoIdpCert,
			"sso_idp_sign_algo":              v.SsoIdpSignAlgo,
			"sso_idp_sso_url":                v.SsoIdpSsoUrl,
			"sso_issuer":                     v.SsoIssuer,
			"sso_nameid_format":              v.SsoNameidFormat,
			"telstra_client_id":              v.TelstraClientId,
			"telstra_client_secret":          v.TelstraClientSecret,
			"twilio_auth_token":              v.TwilioAuthToken,
			"twilio_phone_number":            v.TwilioPhoneNumber,
			"twilio_sid":                     v.TwilioSid,
		})

	return objVal, diags
}

func (v PortalValue) Equal(o attr.Value) bool {
	other, ok := o.(PortalValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmazonClientId.Equal(other.AmazonClientId) {
		return false
	}

	if !v.AmazonClientSecret.Equal(other.AmazonClientSecret) {
		return false
	}

	if !v.AmazonEmailDomains.Equal(other.AmazonEmailDomains) {
		return false
	}

	if !v.AmazonEnabled.Equal(other.AmazonEnabled) {
		return false
	}

	if !v.AmazonExpire.Equal(other.AmazonExpire) {
		return false
	}

	if !v.Auth.Equal(other.Auth) {
		return false
	}

	if !v.AzureClientId.Equal(other.AzureClientId) {
		return false
	}

	if !v.AzureClientSecret.Equal(other.AzureClientSecret) {
		return false
	}

	if !v.AzureEnabled.Equal(other.AzureEnabled) {
		return false
	}

	if !v.AzureExpire.Equal(other.AzureExpire) {
		return false
	}

	if !v.AzureTenantId.Equal(other.AzureTenantId) {
		return false
	}

	if !v.BroadnetPassword.Equal(other.BroadnetPassword) {
		return false
	}

	if !v.BroadnetSid.Equal(other.BroadnetSid) {
		return false
	}

	if !v.BroadnetUserId.Equal(other.BroadnetUserId) {
		return false
	}

	if !v.BypassWhenCloudDown.Equal(other.BypassWhenCloudDown) {
		return false
	}

	if !v.ClickatellApiKey.Equal(other.ClickatellApiKey) {
		return false
	}

	if !v.CrossSite.Equal(other.CrossSite) {
		return false
	}

	if !v.EmailEnabled.Equal(other.EmailEnabled) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Expire.Equal(other.Expire) {
		return false
	}

	if !v.ExternalPortalUrl.Equal(other.ExternalPortalUrl) {
		return false
	}

	if !v.FacebookClientId.Equal(other.FacebookClientId) {
		return false
	}

	if !v.FacebookClientSecret.Equal(other.FacebookClientSecret) {
		return false
	}

	if !v.FacebookEmailDomains.Equal(other.FacebookEmailDomains) {
		return false
	}

	if !v.FacebookEnabled.Equal(other.FacebookEnabled) {
		return false
	}

	if !v.FacebookExpire.Equal(other.FacebookExpire) {
		return false
	}

	if !v.Forward.Equal(other.Forward) {
		return false
	}

	if !v.ForwardUrl.Equal(other.ForwardUrl) {
		return false
	}

	if !v.GoogleClientId.Equal(other.GoogleClientId) {
		return false
	}

	if !v.GoogleClientSecret.Equal(other.GoogleClientSecret) {
		return false
	}

	if !v.GoogleEmailDomains.Equal(other.GoogleEmailDomains) {
		return false
	}

	if !v.GoogleEnabled.Equal(other.GoogleEnabled) {
		return false
	}

	if !v.GoogleExpire.Equal(other.GoogleExpire) {
		return false
	}

	if !v.GupshupPassword.Equal(other.GupshupPassword) {
		return false
	}

	if !v.GupshupUserid.Equal(other.GupshupUserid) {
		return false
	}

	if !v.MicrosoftClientId.Equal(other.MicrosoftClientId) {
		return false
	}

	if !v.MicrosoftClientSecret.Equal(other.MicrosoftClientSecret) {
		return false
	}

	if !v.MicrosoftEmailDomains.Equal(other.MicrosoftEmailDomains) {
		return false
	}

	if !v.MicrosoftEnabled.Equal(other.MicrosoftEnabled) {
		return false
	}

	if !v.MicrosoftExpire.Equal(other.MicrosoftExpire) {
		return false
	}

	if !v.PassphraseEnabled.Equal(other.PassphraseEnabled) {
		return false
	}

	if !v.PassphraseExpire.Equal(other.PassphraseExpire) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.PortalApiSecret.Equal(other.PortalApiSecret) {
		return false
	}

	if !v.PortalImage.Equal(other.PortalImage) {
		return false
	}

	if !v.PortalSsoUrl.Equal(other.PortalSsoUrl) {
		return false
	}

	if !v.PredefinedSponsorsEnabled.Equal(other.PredefinedSponsorsEnabled) {
		return false
	}

	if !v.Privacy.Equal(other.Privacy) {
		return false
	}

	if !v.PuzzelPassword.Equal(other.PuzzelPassword) {
		return false
	}

	if !v.PuzzelServiceId.Equal(other.PuzzelServiceId) {
		return false
	}

	if !v.PuzzelUsername.Equal(other.PuzzelUsername) {
		return false
	}

	if !v.SmsEnabled.Equal(other.SmsEnabled) {
		return false
	}

	if !v.SmsExpire.Equal(other.SmsExpire) {
		return false
	}

	if !v.SmsMessageFormat.Equal(other.SmsMessageFormat) {
		return false
	}

	if !v.SmsProvider.Equal(other.SmsProvider) {
		return false
	}

	if !v.SponsorAutoApprove.Equal(other.SponsorAutoApprove) {
		return false
	}

	if !v.SponsorEmailDomains.Equal(other.SponsorEmailDomains) {
		return false
	}

	if !v.SponsorEnabled.Equal(other.SponsorEnabled) {
		return false
	}

	if !v.SponsorExpire.Equal(other.SponsorExpire) {
		return false
	}

	if !v.SponsorLinkValidityDuration.Equal(other.SponsorLinkValidityDuration) {
		return false
	}

	if !v.SponsorNotifyAll.Equal(other.SponsorNotifyAll) {
		return false
	}

	if !v.SponsorStatusNotify.Equal(other.SponsorStatusNotify) {
		return false
	}

	if !v.Sponsors.Equal(other.Sponsors) {
		return false
	}

	if !v.SsoDefaultRole.Equal(other.SsoDefaultRole) {
		return false
	}

	if !v.SsoForcedRole.Equal(other.SsoForcedRole) {
		return false
	}

	if !v.SsoIdpCert.Equal(other.SsoIdpCert) {
		return false
	}

	if !v.SsoIdpSignAlgo.Equal(other.SsoIdpSignAlgo) {
		return false
	}

	if !v.SsoIdpSsoUrl.Equal(other.SsoIdpSsoUrl) {
		return false
	}

	if !v.SsoIssuer.Equal(other.SsoIssuer) {
		return false
	}

	if !v.SsoNameidFormat.Equal(other.SsoNameidFormat) {
		return false
	}

	if !v.TelstraClientId.Equal(other.TelstraClientId) {
		return false
	}

	if !v.TelstraClientSecret.Equal(other.TelstraClientSecret) {
		return false
	}

	if !v.TwilioAuthToken.Equal(other.TwilioAuthToken) {
		return false
	}

	if !v.TwilioPhoneNumber.Equal(other.TwilioPhoneNumber) {
		return false
	}

	if !v.TwilioSid.Equal(other.TwilioSid) {
		return false
	}

	return true
}

func (v PortalValue) Type(ctx context.Context) attr.Type {
	return PortalType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortalValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amazon_client_id":     basetypes.StringType{},
		"amazon_client_secret": basetypes.StringType{},
		"amazon_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"amazon_enabled":         basetypes.BoolType{},
		"amazon_expire":          basetypes.Float64Type{},
		"auth":                   basetypes.StringType{},
		"azure_client_id":        basetypes.StringType{},
		"azure_client_secret":    basetypes.StringType{},
		"azure_enabled":          basetypes.BoolType{},
		"azure_expire":           basetypes.Float64Type{},
		"azure_tenant_id":        basetypes.StringType{},
		"broadnet_password":      basetypes.StringType{},
		"broadnet_sid":           basetypes.StringType{},
		"broadnet_user_id":       basetypes.StringType{},
		"bypass_when_cloud_down": basetypes.BoolType{},
		"clickatell_api_key":     basetypes.StringType{},
		"cross_site":             basetypes.BoolType{},
		"email_enabled":          basetypes.BoolType{},
		"enabled":                basetypes.BoolType{},
		"expire":                 basetypes.Float64Type{},
		"external_portal_url":    basetypes.StringType{},
		"facebook_client_id":     basetypes.StringType{},
		"facebook_client_secret": basetypes.StringType{},
		"facebook_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"facebook_enabled":     basetypes.BoolType{},
		"facebook_expire":      basetypes.Float64Type{},
		"forward":              basetypes.BoolType{},
		"forward_url":          basetypes.StringType{},
		"google_client_id":     basetypes.StringType{},
		"google_client_secret": basetypes.StringType{},
		"google_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"google_enabled":          basetypes.BoolType{},
		"google_expire":           basetypes.Float64Type{},
		"gupshup_password":        basetypes.StringType{},
		"gupshup_userid":          basetypes.StringType{},
		"microsoft_client_id":     basetypes.StringType{},
		"microsoft_client_secret": basetypes.StringType{},
		"microsoft_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"microsoft_enabled":           basetypes.BoolType{},
		"microsoft_expire":            basetypes.Float64Type{},
		"passphrase_enabled":          basetypes.BoolType{},
		"passphrase_expire":           basetypes.Float64Type{},
		"password":                    basetypes.StringType{},
		"portal_api_secret":           basetypes.StringType{},
		"portal_image":                basetypes.StringType{},
		"portal_sso_url":              basetypes.StringType{},
		"predefined_sponsors_enabled": basetypes.BoolType{},
		"privacy":                     basetypes.BoolType{},
		"puzzel_password":             basetypes.StringType{},
		"puzzel_service_id":           basetypes.StringType{},
		"puzzel_username":             basetypes.StringType{},
		"sms_enabled":                 basetypes.BoolType{},
		"sms_expire":                  basetypes.Float64Type{},
		"sms_message_format":          basetypes.StringType{},
		"sms_provider":                basetypes.StringType{},
		"sponsor_auto_approve":        basetypes.BoolType{},
		"sponsor_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"sponsor_enabled":                basetypes.BoolType{},
		"sponsor_expire":                 basetypes.Float64Type{},
		"sponsor_link_validity_duration": basetypes.Int64Type{},
		"sponsor_notify_all":             basetypes.BoolType{},
		"sponsor_status_notify":          basetypes.BoolType{},
		"sponsors": basetypes.MapType{
			ElemType: types.StringType,
		},
		"sso_default_role":      basetypes.StringType{},
		"sso_forced_role":       basetypes.StringType{},
		"sso_idp_cert":          basetypes.StringType{},
		"sso_idp_sign_algo":     basetypes.StringType{},
		"sso_idp_sso_url":       basetypes.StringType{},
		"sso_issuer":            basetypes.StringType{},
		"sso_nameid_format":     basetypes.StringType{},
		"telstra_client_id":     basetypes.StringType{},
		"telstra_client_secret": basetypes.StringType{},
		"twilio_auth_token":     basetypes.StringType{},
		"twilio_phone_number":   basetypes.StringType{},
		"twilio_sid":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = QosType{}

type QosType struct {
	basetypes.ObjectType
}

func (t QosType) Equal(o attr.Type) bool {
	other, ok := o.(QosType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QosType) String() string {
	return "QosType"
}

func (t QosType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	classAttribute, ok := attributes["class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`class is missing from object`)

		return nil, diags
	}

	classVal, ok := classAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`class expected to be basetypes.StringValue, was: %T`, classAttribute))
	}

	overwriteAttribute, ok := attributes["overwrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overwrite is missing from object`)

		return nil, diags
	}

	overwriteVal, ok := overwriteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overwrite expected to be basetypes.BoolValue, was: %T`, overwriteAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QosValue{
		Class:     classVal,
		Overwrite: overwriteVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewQosValueNull() QosValue {
	return QosValue{
		state: attr.ValueStateNull,
	}
}

func NewQosValueUnknown() QosValue {
	return QosValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQosValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QosValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QosValue Attribute Value",
				"While creating a QosValue value, a missing attribute value was detected. "+
					"A QosValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QosValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QosValue Attribute Type",
				"While creating a QosValue value, an invalid attribute value was detected. "+
					"A QosValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QosValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QosValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QosValue Attribute Value",
				"While creating a QosValue value, an extra attribute value was detected. "+
					"A QosValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QosValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQosValueUnknown(), diags
	}

	classAttribute, ok := attributes["class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`class is missing from object`)

		return NewQosValueUnknown(), diags
	}

	classVal, ok := classAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`class expected to be basetypes.StringValue, was: %T`, classAttribute))
	}

	overwriteAttribute, ok := attributes["overwrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overwrite is missing from object`)

		return NewQosValueUnknown(), diags
	}

	overwriteVal, ok := overwriteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overwrite expected to be basetypes.BoolValue, was: %T`, overwriteAttribute))
	}

	if diags.HasError() {
		return NewQosValueUnknown(), diags
	}

	return QosValue{
		Class:     classVal,
		Overwrite: overwriteVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewQosValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QosValue {
	object, diags := NewQosValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQosValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QosType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQosValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQosValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQosValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQosValueMust(QosValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QosType) ValueType(ctx context.Context) attr.Value {
	return QosValue{}
}

var _ basetypes.ObjectValuable = QosValue{}

type QosValue struct {
	Class     basetypes.StringValue `tfsdk:"class"`
	Overwrite basetypes.BoolValue   `tfsdk:"overwrite"`
	state     attr.ValueState
}

func (v QosValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["class"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["overwrite"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Class.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["class"] = val

		val, err = v.Overwrite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["overwrite"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QosValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QosValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QosValue) String() string {
	return "QosValue"
}

func (v QosValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"class":     basetypes.StringType{},
		"overwrite": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"class":     v.Class,
			"overwrite": v.Overwrite,
		})

	return objVal, diags
}

func (v QosValue) Equal(o attr.Value) bool {
	other, ok := o.(QosValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Class.Equal(other.Class) {
		return false
	}

	if !v.Overwrite.Equal(other.Overwrite) {
		return false
	}

	return true
}

func (v QosValue) Type(ctx context.Context) attr.Type {
	return QosType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QosValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"class":     basetypes.StringType{},
		"overwrite": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = RadsecType{}

type RadsecType struct {
	basetypes.ObjectType
}

func (t RadsecType) Equal(o attr.Type) bool {
	other, ok := o.(RadsecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RadsecType) String() string {
	return "RadsecType"
}

func (t RadsecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return nil, diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	idleTimeoutAttribute, ok := attributes["idle_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_timeout is missing from object`)

		return nil, diags
	}

	idleTimeoutVal, ok := idleTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_timeout expected to be basetypes.Int64Value, was: %T`, idleTimeoutAttribute))
	}

	mxclusterIdsAttribute, ok := attributes["mxcluster_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxcluster_ids is missing from object`)

		return nil, diags
	}

	mxclusterIdsVal, ok := mxclusterIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxcluster_ids expected to be basetypes.ListValue, was: %T`, mxclusterIdsAttribute))
	}

	proxyHostsAttribute, ok := attributes["proxy_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_hosts is missing from object`)

		return nil, diags
	}

	proxyHostsVal, ok := proxyHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_hosts expected to be basetypes.ListValue, was: %T`, proxyHostsAttribute))
	}

	serverNameAttribute, ok := attributes["server_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_name is missing from object`)

		return nil, diags
	}

	serverNameVal, ok := serverNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_name expected to be basetypes.StringValue, was: %T`, serverNameAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return nil, diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	useMxedgeAttribute, ok := attributes["use_mxedge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mxedge is missing from object`)

		return nil, diags
	}

	useMxedgeVal, ok := useMxedgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mxedge expected to be basetypes.BoolValue, was: %T`, useMxedgeAttribute))
	}

	useSiteMxedgeAttribute, ok := attributes["use_site_mxedge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_site_mxedge is missing from object`)

		return nil, diags
	}

	useSiteMxedgeVal, ok := useSiteMxedgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_site_mxedge expected to be basetypes.BoolValue, was: %T`, useSiteMxedgeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RadsecValue{
		CoaEnabled:    coaEnabledVal,
		Enabled:       enabledVal,
		IdleTimeout:   idleTimeoutVal,
		MxclusterIds:  mxclusterIdsVal,
		ProxyHosts:    proxyHostsVal,
		ServerName:    serverNameVal,
		Servers:       serversVal,
		UseMxedge:     useMxedgeVal,
		UseSiteMxedge: useSiteMxedgeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewRadsecValueNull() RadsecValue {
	return RadsecValue{
		state: attr.ValueStateNull,
	}
}

func NewRadsecValueUnknown() RadsecValue {
	return RadsecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRadsecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RadsecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RadsecValue Attribute Value",
				"While creating a RadsecValue value, a missing attribute value was detected. "+
					"A RadsecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadsecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RadsecValue Attribute Type",
				"While creating a RadsecValue value, an invalid attribute value was detected. "+
					"A RadsecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadsecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RadsecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RadsecValue Attribute Value",
				"While creating a RadsecValue value, an extra attribute value was detected. "+
					"A RadsecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RadsecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRadsecValueUnknown(), diags
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	idleTimeoutAttribute, ok := attributes["idle_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_timeout is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	idleTimeoutVal, ok := idleTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_timeout expected to be basetypes.Int64Value, was: %T`, idleTimeoutAttribute))
	}

	mxclusterIdsAttribute, ok := attributes["mxcluster_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxcluster_ids is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	mxclusterIdsVal, ok := mxclusterIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxcluster_ids expected to be basetypes.ListValue, was: %T`, mxclusterIdsAttribute))
	}

	proxyHostsAttribute, ok := attributes["proxy_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_hosts is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	proxyHostsVal, ok := proxyHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_hosts expected to be basetypes.ListValue, was: %T`, proxyHostsAttribute))
	}

	serverNameAttribute, ok := attributes["server_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_name is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	serverNameVal, ok := serverNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_name expected to be basetypes.StringValue, was: %T`, serverNameAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	useMxedgeAttribute, ok := attributes["use_mxedge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mxedge is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	useMxedgeVal, ok := useMxedgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mxedge expected to be basetypes.BoolValue, was: %T`, useMxedgeAttribute))
	}

	useSiteMxedgeAttribute, ok := attributes["use_site_mxedge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_site_mxedge is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	useSiteMxedgeVal, ok := useSiteMxedgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_site_mxedge expected to be basetypes.BoolValue, was: %T`, useSiteMxedgeAttribute))
	}

	if diags.HasError() {
		return NewRadsecValueUnknown(), diags
	}

	return RadsecValue{
		CoaEnabled:    coaEnabledVal,
		Enabled:       enabledVal,
		IdleTimeout:   idleTimeoutVal,
		MxclusterIds:  mxclusterIdsVal,
		ProxyHosts:    proxyHostsVal,
		ServerName:    serverNameVal,
		Servers:       serversVal,
		UseMxedge:     useMxedgeVal,
		UseSiteMxedge: useSiteMxedgeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewRadsecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RadsecValue {
	object, diags := NewRadsecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRadsecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RadsecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRadsecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRadsecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRadsecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRadsecValueMust(RadsecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RadsecType) ValueType(ctx context.Context) attr.Value {
	return RadsecValue{}
}

var _ basetypes.ObjectValuable = RadsecValue{}

type RadsecValue struct {
	CoaEnabled    basetypes.BoolValue   `tfsdk:"coa_enabled"`
	Enabled       basetypes.BoolValue   `tfsdk:"enabled"`
	IdleTimeout   basetypes.Int64Value  `tfsdk:"idle_timeout"`
	MxclusterIds  basetypes.ListValue   `tfsdk:"mxcluster_ids"`
	ProxyHosts    basetypes.ListValue   `tfsdk:"proxy_hosts"`
	ServerName    basetypes.StringValue `tfsdk:"server_name"`
	Servers       basetypes.ListValue   `tfsdk:"servers"`
	UseMxedge     basetypes.BoolValue   `tfsdk:"use_mxedge"`
	UseSiteMxedge basetypes.BoolValue   `tfsdk:"use_site_mxedge"`
	state         attr.ValueState
}

func (v RadsecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["coa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["idle_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mxcluster_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["proxy_hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["server_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["servers"] = basetypes.ListType{
		ElemType: ServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["use_mxedge"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["use_site_mxedge"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.CoaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_enabled"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.IdleTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idle_timeout"] = val

		val, err = v.MxclusterIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mxcluster_ids"] = val

		val, err = v.ProxyHosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_hosts"] = val

		val, err = v.ServerName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_name"] = val

		val, err = v.Servers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers"] = val

		val, err = v.UseMxedge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mxedge"] = val

		val, err = v.UseSiteMxedge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_site_mxedge"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RadsecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RadsecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RadsecValue) String() string {
	return "RadsecValue"
}

func (v RadsecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	servers := types.ListValueMust(
		ServersType{
			basetypes.ObjectType{
				AttrTypes: ServersValue{}.AttributeTypes(ctx),
			},
		},
		v.Servers.Elements(),
	)

	if v.Servers.IsNull() {
		servers = types.ListNull(
			ServersType{
				basetypes.ObjectType{
					AttrTypes: ServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Servers.IsUnknown() {
		servers = types.ListUnknown(
			ServersType{
				basetypes.ObjectType{
					AttrTypes: ServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	mxclusterIdsVal, d := types.ListValue(types.StringType, v.MxclusterIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"coa_enabled":  basetypes.BoolType{},
			"enabled":      basetypes.BoolType{},
			"idle_timeout": basetypes.Int64Type{},
			"mxcluster_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"proxy_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"server_name": basetypes.StringType{},
			"servers": basetypes.ListType{
				ElemType: ServersValue{}.Type(ctx),
			},
			"use_mxedge":      basetypes.BoolType{},
			"use_site_mxedge": basetypes.BoolType{},
		}), diags
	}

	proxyHostsVal, d := types.ListValue(types.StringType, v.ProxyHosts.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"coa_enabled":  basetypes.BoolType{},
			"enabled":      basetypes.BoolType{},
			"idle_timeout": basetypes.Int64Type{},
			"mxcluster_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"proxy_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"server_name": basetypes.StringType{},
			"servers": basetypes.ListType{
				ElemType: ServersValue{}.Type(ctx),
			},
			"use_mxedge":      basetypes.BoolType{},
			"use_site_mxedge": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"coa_enabled":  basetypes.BoolType{},
		"enabled":      basetypes.BoolType{},
		"idle_timeout": basetypes.Int64Type{},
		"mxcluster_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"proxy_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"server_name": basetypes.StringType{},
		"servers": basetypes.ListType{
			ElemType: ServersValue{}.Type(ctx),
		},
		"use_mxedge":      basetypes.BoolType{},
		"use_site_mxedge": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"coa_enabled":     v.CoaEnabled,
			"enabled":         v.Enabled,
			"idle_timeout":    v.IdleTimeout,
			"mxcluster_ids":   mxclusterIdsVal,
			"proxy_hosts":     proxyHostsVal,
			"server_name":     v.ServerName,
			"servers":         servers,
			"use_mxedge":      v.UseMxedge,
			"use_site_mxedge": v.UseSiteMxedge,
		})

	return objVal, diags
}

func (v RadsecValue) Equal(o attr.Value) bool {
	other, ok := o.(RadsecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CoaEnabled.Equal(other.CoaEnabled) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.IdleTimeout.Equal(other.IdleTimeout) {
		return false
	}

	if !v.MxclusterIds.Equal(other.MxclusterIds) {
		return false
	}

	if !v.ProxyHosts.Equal(other.ProxyHosts) {
		return false
	}

	if !v.ServerName.Equal(other.ServerName) {
		return false
	}

	if !v.Servers.Equal(other.Servers) {
		return false
	}

	if !v.UseMxedge.Equal(other.UseMxedge) {
		return false
	}

	if !v.UseSiteMxedge.Equal(other.UseSiteMxedge) {
		return false
	}

	return true
}

func (v RadsecValue) Type(ctx context.Context) attr.Type {
	return RadsecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RadsecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"coa_enabled":  basetypes.BoolType{},
		"enabled":      basetypes.BoolType{},
		"idle_timeout": basetypes.Int64Type{},
		"mxcluster_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"proxy_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"server_name": basetypes.StringType{},
		"servers": basetypes.ListType{
			ElemType: ServersValue{}.Type(ctx),
		},
		"use_mxedge":      basetypes.BoolType{},
		"use_site_mxedge": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ServersType{}

type ServersType struct {
	basetypes.ObjectType
}

func (t ServersType) Equal(o attr.Type) bool {
	other, ok := o.(ServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServersType) String() string {
	return "ServersType"
}

func (t ServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServersValue{
		Host:  hostVal,
		Port:  portVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewServersValueNull() ServersValue {
	return ServersValue{
		state: attr.ValueStateNull,
	}
}

func NewServersValueUnknown() ServersValue {
	return ServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServersValue Attribute Value",
				"While creating a ServersValue value, a missing attribute value was detected. "+
					"A ServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServersValue Attribute Type",
				"While creating a ServersValue value, an invalid attribute value was detected. "+
					"A ServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServersValue Attribute Value",
				"While creating a ServersValue value, an extra attribute value was detected. "+
					"A ServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return NewServersValueUnknown(), diags
	}

	return ServersValue{
		Host:  hostVal,
		Port:  portVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServersValue {
	object, diags := NewServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServersValueMust(ServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServersType) ValueType(ctx context.Context) attr.Value {
	return ServersValue{}
}

var _ basetypes.ObjectValuable = ServersValue{}

type ServersValue struct {
	Host  basetypes.StringValue `tfsdk:"host"`
	Port  basetypes.Int64Value  `tfsdk:"port"`
	state attr.ValueState
}

func (v ServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServersValue) String() string {
	return "ServersValue"
}

func (v ServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host": basetypes.StringType{},
		"port": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host": v.Host,
			"port": v.Port,
		})

	return objVal, diags
}

func (v ServersValue) Equal(o attr.Value) bool {
	other, ok := o.(ServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	return true
}

func (v ServersValue) Type(ctx context.Context) attr.Type {
	return ServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host": basetypes.StringType{},
		"port": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ScheduleType{}

type ScheduleType struct {
	basetypes.ObjectType
}

func (t ScheduleType) Equal(o attr.Type) bool {
	other, ok := o.(ScheduleType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ScheduleType) String() string {
	return "ScheduleType"
}

func (t ScheduleType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hoursAttribute, ok := attributes["hours"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hours is missing from object`)

		return nil, diags
	}

	hoursVal, ok := hoursAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hours expected to be basetypes.ObjectValue, was: %T`, hoursAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ScheduleValue{
		Enabled: enabledVal,
		Hours:   hoursVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewScheduleValueNull() ScheduleValue {
	return ScheduleValue{
		state: attr.ValueStateNull,
	}
}

func NewScheduleValueUnknown() ScheduleValue {
	return ScheduleValue{
		state: attr.ValueStateUnknown,
	}
}

func NewScheduleValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ScheduleValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ScheduleValue Attribute Value",
				"While creating a ScheduleValue value, a missing attribute value was detected. "+
					"A ScheduleValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScheduleValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ScheduleValue Attribute Type",
				"While creating a ScheduleValue value, an invalid attribute value was detected. "+
					"A ScheduleValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScheduleValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ScheduleValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ScheduleValue Attribute Value",
				"While creating a ScheduleValue value, an extra attribute value was detected. "+
					"A ScheduleValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ScheduleValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewScheduleValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewScheduleValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hoursAttribute, ok := attributes["hours"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hours is missing from object`)

		return NewScheduleValueUnknown(), diags
	}

	hoursVal, ok := hoursAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hours expected to be basetypes.ObjectValue, was: %T`, hoursAttribute))
	}

	if diags.HasError() {
		return NewScheduleValueUnknown(), diags
	}

	return ScheduleValue{
		Enabled: enabledVal,
		Hours:   hoursVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewScheduleValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ScheduleValue {
	object, diags := NewScheduleValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewScheduleValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ScheduleType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewScheduleValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewScheduleValueUnknown(), nil
	}

	if in.IsNull() {
		return NewScheduleValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewScheduleValueMust(ScheduleValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ScheduleType) ValueType(ctx context.Context) attr.Value {
	return ScheduleValue{}
}

var _ basetypes.ObjectValuable = ScheduleValue{}

type ScheduleValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Hours   basetypes.ObjectValue `tfsdk:"hours"`
	state   attr.ValueState
}

func (v ScheduleValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hours"] = basetypes.ObjectType{
		AttrTypes: HoursValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Hours.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hours"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ScheduleValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ScheduleValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ScheduleValue) String() string {
	return "ScheduleValue"
}

func (v ScheduleValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var hours basetypes.ObjectValue

	if v.Hours.IsNull() {
		hours = types.ObjectNull(
			HoursValue{}.AttributeTypes(ctx),
		)
	}

	if v.Hours.IsUnknown() {
		hours = types.ObjectUnknown(
			HoursValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Hours.IsNull() && !v.Hours.IsUnknown() {
		hours = types.ObjectValueMust(
			HoursValue{}.AttributeTypes(ctx),
			v.Hours.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"hours": basetypes.ObjectType{
			AttrTypes: HoursValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"hours":   hours,
		})

	return objVal, diags
}

func (v ScheduleValue) Equal(o attr.Value) bool {
	other, ok := o.(ScheduleValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Hours.Equal(other.Hours) {
		return false
	}

	return true
}

func (v ScheduleValue) Type(ctx context.Context) attr.Type {
	return ScheduleType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ScheduleValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"hours": basetypes.ObjectType{
			AttrTypes: HoursValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = HoursType{}

type HoursType struct {
	basetypes.ObjectType
}

func (t HoursType) Equal(o attr.Type) bool {
	other, ok := o.(HoursType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HoursType) String() string {
	return "HoursType"
}

func (t HoursType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	friAttribute, ok := attributes["fri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fri is missing from object`)

		return nil, diags
	}

	friVal, ok := friAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fri expected to be basetypes.StringValue, was: %T`, friAttribute))
	}

	monAttribute, ok := attributes["mon"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mon is missing from object`)

		return nil, diags
	}

	monVal, ok := monAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mon expected to be basetypes.StringValue, was: %T`, monAttribute))
	}

	satAttribute, ok := attributes["sat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sat is missing from object`)

		return nil, diags
	}

	satVal, ok := satAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sat expected to be basetypes.StringValue, was: %T`, satAttribute))
	}

	sunAttribute, ok := attributes["sun"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sun is missing from object`)

		return nil, diags
	}

	sunVal, ok := sunAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sun expected to be basetypes.StringValue, was: %T`, sunAttribute))
	}

	thuAttribute, ok := attributes["thu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thu is missing from object`)

		return nil, diags
	}

	thuVal, ok := thuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thu expected to be basetypes.StringValue, was: %T`, thuAttribute))
	}

	tueAttribute, ok := attributes["tue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tue is missing from object`)

		return nil, diags
	}

	tueVal, ok := tueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tue expected to be basetypes.StringValue, was: %T`, tueAttribute))
	}

	wedAttribute, ok := attributes["wed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wed is missing from object`)

		return nil, diags
	}

	wedVal, ok := wedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wed expected to be basetypes.StringValue, was: %T`, wedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HoursValue{
		Fri:   friVal,
		Mon:   monVal,
		Sat:   satVal,
		Sun:   sunVal,
		Thu:   thuVal,
		Tue:   tueVal,
		Wed:   wedVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewHoursValueNull() HoursValue {
	return HoursValue{
		state: attr.ValueStateNull,
	}
}

func NewHoursValueUnknown() HoursValue {
	return HoursValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHoursValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HoursValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HoursValue Attribute Value",
				"While creating a HoursValue value, a missing attribute value was detected. "+
					"A HoursValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HoursValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HoursValue Attribute Type",
				"While creating a HoursValue value, an invalid attribute value was detected. "+
					"A HoursValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HoursValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HoursValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HoursValue Attribute Value",
				"While creating a HoursValue value, an extra attribute value was detected. "+
					"A HoursValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HoursValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHoursValueUnknown(), diags
	}

	friAttribute, ok := attributes["fri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fri is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	friVal, ok := friAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fri expected to be basetypes.StringValue, was: %T`, friAttribute))
	}

	monAttribute, ok := attributes["mon"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mon is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	monVal, ok := monAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mon expected to be basetypes.StringValue, was: %T`, monAttribute))
	}

	satAttribute, ok := attributes["sat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sat is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	satVal, ok := satAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sat expected to be basetypes.StringValue, was: %T`, satAttribute))
	}

	sunAttribute, ok := attributes["sun"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sun is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	sunVal, ok := sunAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sun expected to be basetypes.StringValue, was: %T`, sunAttribute))
	}

	thuAttribute, ok := attributes["thu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thu is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	thuVal, ok := thuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thu expected to be basetypes.StringValue, was: %T`, thuAttribute))
	}

	tueAttribute, ok := attributes["tue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tue is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	tueVal, ok := tueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tue expected to be basetypes.StringValue, was: %T`, tueAttribute))
	}

	wedAttribute, ok := attributes["wed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wed is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	wedVal, ok := wedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wed expected to be basetypes.StringValue, was: %T`, wedAttribute))
	}

	if diags.HasError() {
		return NewHoursValueUnknown(), diags
	}

	return HoursValue{
		Fri:   friVal,
		Mon:   monVal,
		Sat:   satVal,
		Sun:   sunVal,
		Thu:   thuVal,
		Tue:   tueVal,
		Wed:   wedVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewHoursValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HoursValue {
	object, diags := NewHoursValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHoursValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HoursType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHoursValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHoursValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHoursValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHoursValueMust(HoursValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HoursType) ValueType(ctx context.Context) attr.Value {
	return HoursValue{}
}

var _ basetypes.ObjectValuable = HoursValue{}

type HoursValue struct {
	Fri   basetypes.StringValue `tfsdk:"fri"`
	Mon   basetypes.StringValue `tfsdk:"mon"`
	Sat   basetypes.StringValue `tfsdk:"sat"`
	Sun   basetypes.StringValue `tfsdk:"sun"`
	Thu   basetypes.StringValue `tfsdk:"thu"`
	Tue   basetypes.StringValue `tfsdk:"tue"`
	Wed   basetypes.StringValue `tfsdk:"wed"`
	state attr.ValueState
}

func (v HoursValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["fri"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mon"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sat"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sun"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["thu"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tue"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wed"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Fri.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fri"] = val

		val, err = v.Mon.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mon"] = val

		val, err = v.Sat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sat"] = val

		val, err = v.Sun.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sun"] = val

		val, err = v.Thu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["thu"] = val

		val, err = v.Tue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tue"] = val

		val, err = v.Wed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wed"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HoursValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HoursValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HoursValue) String() string {
	return "HoursValue"
}

func (v HoursValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"fri": basetypes.StringType{},
		"mon": basetypes.StringType{},
		"sat": basetypes.StringType{},
		"sun": basetypes.StringType{},
		"thu": basetypes.StringType{},
		"tue": basetypes.StringType{},
		"wed": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"fri": v.Fri,
			"mon": v.Mon,
			"sat": v.Sat,
			"sun": v.Sun,
			"thu": v.Thu,
			"tue": v.Tue,
			"wed": v.Wed,
		})

	return objVal, diags
}

func (v HoursValue) Equal(o attr.Value) bool {
	other, ok := o.(HoursValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Fri.Equal(other.Fri) {
		return false
	}

	if !v.Mon.Equal(other.Mon) {
		return false
	}

	if !v.Sat.Equal(other.Sat) {
		return false
	}

	if !v.Sun.Equal(other.Sun) {
		return false
	}

	if !v.Thu.Equal(other.Thu) {
		return false
	}

	if !v.Tue.Equal(other.Tue) {
		return false
	}

	if !v.Wed.Equal(other.Wed) {
		return false
	}

	return true
}

func (v HoursValue) Type(ctx context.Context) attr.Type {
	return HoursType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HoursValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"fri": basetypes.StringType{},
		"mon": basetypes.StringType{},
		"sat": basetypes.StringType{},
		"sun": basetypes.StringType{},
		"thu": basetypes.StringType{},
		"tue": basetypes.StringType{},
		"wed": basetypes.StringType{},
	}
}
